# mod_commands 

---

目录（点击展开）

* [0. 关于](#command-2)
* [1. 使用方法](#command-2)
   * [1.1 命令行界面](#command-2)
   * [1.2 API/事件接口](#12-apievent-interfaces-)
   * [1.3 脚本接口](#13-scripting-interfaces-)
   * [1.4 来自拨号计划](#command-2)
* [2. 返回数据的格式](#2-format-of-returned-data)
* [3. 核心命令](#3-core-commands)
   * [3.1 acl](#command-2)
      * [3.1.1 语法](#311-syntax)
         * [3.1.2 示例](#312-examples)
   * [3.2 alias](#command-2)
      * [3.2.1 语法](#311-syntax)
         * [3.2.2 示例](#312-examples)
   * [3.3 bgapi](#command-2)
      * [3.3.1 语法](#311-syntax)
         * [3.3.2 示例](#312-examples)
* [cond](#command-2)
* [domain\_exists](#domain_exists)
* [eval](#command-2)
* [expand](#command-2)
* [fsctl](#command-2)
   * [api\_expansion](#api_expansion--)
   * [calibrate\_clock](#calibrate_clock)
   * [debug\_level](#debug_level-)
   * [debug\_sql](#command-2)
   * [default\_dtmf\_duration](#default_dtmf_duration)
   * [flush\_db\_handles](#flush_db_handles)
   * [hupall](#command-2)
   * [last\_sps](#command-2)
   * [loglevel](#loglevel)
   * [max\_sessions](#max_sessions)
   * [max\_dtmf\_duration](#max_dtmf_duration)
   * [min\_dtmf\_duration](#max_dtmf_duration)
   * [min\_idle\_cpu](#command-2)
   * [pause](#command-2)
   * [pause\_check](#pause_check)
   * [ready\_check](#ready_check)
   * [reclaim\_mem](#reclaim_mem)
   * [recover](#recover)
   * [resume](#command-2)
   * [save\_history](#save_history)
   * [send\_sighup](#send_sighup)
   * [shutdown](#command-2)
   * [shutdown\_check](#shutdown_check)
   * [sps](#command-2)
   * [sync\_clock](#sync_clock)
   * [sync\_clock\_when\_idle](#sync_clock_when_idle)
   * [verbose\_events](#verbose_events)
* [global\_getvar](#global_getvar)
* [global\_setvar](#global_setvar)
* [group](#command-2)
* [group\_call](#group_call)
* [help](#command-2)
* [host\_lookup](#host_lookup)
* [hupall](#command-2)
* [in\_group](#command-2)
* [is\_lan\_addr](#command-2)
* [json](#command-2)
* [load](#command-2)
* [md5](#command-2)
* [module\_exists](#domain_exists)
* [msleep](#command-2)
* [nat\_map](#command-2)
* [regex](#command-2)
* [reload](#command-2)
* [reloadacl](#reloadacl)
* [reloadxml](#reloadxml)
* [show](#command-2)
   * [显示呼叫和通道的提示](#tips-for-showing-calls-and-channels-)
* [shutdown](#shutdown)
* [status](#command-2)
* [strftime\_tz](#strftime_tz)
* [unload](#command-2)
* [version](#version)
* [xml\_locate](#xml_locate)
* [xml\_wrap](#command-2)
* [呼叫管理命令](#call-management-commands)
* [break](#command-2)
* [create\_uuid](#create_uuid)
* [originate](#originate)
   * [参数](#arguments)
   * [变量](#variables)
   * [示例](#examples)
* [pause](#command-2)
* [uuid\_answer](#uuid_answer)
* [uuid\_audio](#uuid_audio)
* [uuid\_break](#uuid_break)
* [uuid\_bridge](#uuid_bridge)
* [uuid\_broadcast](#uuid_broadcast)
* [uuid\_buglist](#uuid_buglist)
* [uuid\_chat](#command-2)
* [uuid\_debug\_media](#uuid_debug_media)
   * [读取格式](#read-format-)
   * [写入格式](#write-format-)
* [uuid\_deflect](#uuid_deflect)
* [uuid\_displace](#uuid_displace)
* [uuid\_display](#uuid_display)
* [uuid\_dual\_transfer](#uuid_dual_transfer)
* [uuid\_dump](#command-2)
* [uuid\_early\_ok](#uuid_early_ok)
* [uuid\_exists](#domain_exists)
* [uuid\_flush\_dtmf](#uuid_flush_dtmf)
* [uuid\_fileman](#uuid_fileman)
* [uuid\_getvar](#uuid_getvar)
* [uuid\_hold](#command-2)
* [uuid\_kill](#command-2)
* [uuid\_limit](#uuid_limit)
* [uuid\_media](#uuid_media)
* [uuid\_media\_reneg](#uuid_media_reneg)
* [uuid\_park](#command-2)
* [uuid\_pre\_answer](#uuid_pre_answer)
* [uuid\_preprocess](#uuid_preprocess)
* [uuid\_recv\_dtmf](#uuid_recv_dtmf)
* [uuid\_send\_dtmf](#uuid_send_dtmf)
* [uuid\_send\_info](#uuid_send_info)
* [uuid\_session\_heartbeat](#uuid_session_heartbeat)
* [uuid\_set\_media\_stats](#uuid_set_media_stats)
* [uuid\_setvar](#uuid_setvar)
* [uuid\_setvar\_multi](#command-2)
* [uuid\_simplify](#uuid_simplify)
* [uuid\_transfer](#uuid_transfer)
* [uuid\_phone\_event](#uuid_phone_event)
* [录音/播放命令](#recordplayback-commands)
* [uuid\_record](#uuid_record)
* [限制命令](#limit-commands)
* [limit\_reset](#limit_reset)
* [limit\_status](#limit_status)
* [limit\_usage](#limit_usage)
* [uuid\_limit\_release](#uuid_limit_release)
* [limit\_interval\_reset](#limit_interval_reset)
* [其他命令](#miscellaneous-commands)
* [bg\_system](#command-2)
* [echo](#command-2)
* [file\_exists](#domain_exists)
* [find\_user\_xml](#find_user_xml)
* [list\_users](#list_users)
* [sched\_api](#command-2)
* [sched\_broadcast](#sched_broadcast)
* [sched\_del](#command-2)
* [sched\_hangup](#sched_hangup)
* [sched\_transfer](#sched_transfer)
* [stun](#command-2)
* [system](#command-2)
* [time\_test](#command-2)
* [timer\_test](#timer_test)
* [tone\_detect](#tone_detect)
* [unsched\_api](#unsched_api)
* [url\_decode](#url_decode)
* [url\_encode](#url_encode)
* [user\_data](#command-2)
* [user\_exists](#domain_exists)
* [参见](#command-2)

### 0. 关于

[mod\_commands](./mod_commands_1966741.mdx#--) 处理[FreeSWITCH API命令](../Introduction/FreeSWITCH-API_30867723.mdx#-freeswitch--freeswitch-api-)。

**FreeSWITCH API**

公共的FreeSWITCH API包括通过以下方式发出到FreeSWITCH的所有命令：
* 控制台 [fs\_cli](https://freeswitch.org/confluence/pages/viewpage.action?pageId=1048948)，
* [事件套接字接口](../Introduction/Glossary_13173966.mdx#event-socket) ，以及
* 脚本接口。

可用命令的集合取决于加载的模块。您安装的命令的权威集合是每个模块注册的命令集合的并集。

要查看可用的API命令列表，只需在[CLI](https://freeswitch.org/confluence/pages/viewpage.action?pageId=1048948)键入 **help** 或 **show api**。

### 1. 使用方法

#### 1.1 [CLI](../Client-and-Developer-Interfaces/1048948.mdx#or)

请参见下方。

#### 1.2 API/事件接口

* [mod\_event\_socket](./mod_event_socket_1048924.mdx#11-acl)
* [mod\_erlang\_event](./mod_erlang_event_1048926.mdx#api-)
* [mod\_xml\_rpc](./mod_xml_rpc_1048928.mdx#about)

#### 1.3 脚本接口

* [mod\_perl](./mod_perl_1048930.mdx#about)
* [mod\_v8](./mod_v8_1048935.mdx#api)
* [mod\_python](./mod_python_1048940.mdx#eol)
* [mod\_lua](./mod_lua_1048944.mdx#--)

#### 1.4 从[Dialplan](../Dialplan/index.mdx#0-about)执行

可以从拨号计划中调用[API命令](../Introduction/FreeSWITCH-API_30867723.mdx#-freeswitch--freeswitch-api-)。示例：

**从拨号计划中调用API命令**

```xml
<扩展名="从Dialplan调用API">
   <条件 字段="destination_number" 表达式="^(999)$">
     <!-- 下一行调用hupall，所以要小心！ -->
     <操作 应用="set" 数据="api_result=${hupall(normal_clearing)}"/>
   </条件>
 </扩展>
```

其他示例：

**其他Dialplan API命令示例**

```xml
<操作 应用="set" 数据="api_result=${status()}"/>
<操作 应用="set" 数据="api_result=${version()}"/>
<操作 应用="set" 数据="api_result=${strftime()}"/>
<操作 应用="set" 数据="api_result=${expr(1+1)}"/>
```

具有多个参数的[API命令](../Introduction/FreeSWITCH-API_30867723.mdx#-freeswitch--freeswitch-api-)通常用空格分隔参数：

**多个参数**

```xml
<操作 应用="set" 数据="api_result=${sched_api(+5 none avmd ${uuid} start)}"/>
```

Dialplan用法


如果您正在从dialplan调用[API命令](../Introduction/FreeSWITCH-API_30867723.mdx#-freeswitch--freeswitch-api-)，请确保没有已经提供所需功能的拨号计划应用程序。请参阅[dptools模块](https://wiki.freeswitch.org/wiki/Mod%5Fdptools "Mod dptools")，获取拨号计划应用程序的列表，它们非常丰富。

### 2. 返回数据的格式

某些状态和列表命令的结果默认以逗号分隔的列表形式呈现。

来自某些模块的数据也可能包含逗号，这样会使结果处理变得困难。您可以通过附加字符串**`作为xml`**来获取以XML格式返回的数据，通过附加字符串**`作为json`**来获取以JSON格式返回的数据，通过附加**`作为delim` `<custom_delimiter>`**来改变默认逗号分隔符的默认格式。

至命令字符串的末尾。

### 3. 核心命令

  
提取脚本

Mitch Capper编写了一个Perl脚本，用于从[mod\_commands](./mod_commands_1966741.mdx#--)的[源代码](https://github.com/signalwire/freeswitch/tree/master/src/mod/applications/mod%5Fcommands)和[mod\_commands.c](https://github.com/signalwire/freeswitch/blob/master/src/mod/applications/mod%5Fcommands/mod%5Fcommands.c)中提取命令，但也适用于大多数其他文件。

**提取Perl脚本** 展开源码 

```perl
#!/usr/bin/perl
use strict;
open (fl,"src/mod/applications/mod_commands/mod_commands.c");
my $cont;
{
	local $/ = undef;
	$cont = <fl>;
}
close fl;
my %DEFINES;
my $reg_define = qr/[A-Za-z0-9_]+/;
my $reg_function = qr/[A-Za-z0-9_]+/;
my $reg_string_or_define = qr/(?:(?:$reg_define)|(?:"[^"]*"))/;

#load defines
while ($cont =~ /
					^\s* \#define \s+ ($reg_define) \s+ \"([^"]*)\"
				/mgx){
	warn "$1被定义多次" if ($DEFINES{$1});
	$DEFINES{$1} = $2;
}
```

```perl
sub resolve_str_or_define($) {
    my ($str) = @_;
    if ($str =~ s/^"// && $str =~ s/"$//) { # 如果字符串以引号开头和结尾，则去除引号并返回字符串
        return $str;
    }
    warn "无法解析定义: $str" if (! $DEFINES{$str});
    return $DEFINES{$str};
}
# 解析命令
while ($cont =~ /
                    SWITCH_ADD_API \s* \( ([^,]+) # 接口 $1
                    ,\s* ($reg_string_or_define) # 命令 $2
                    ,\s* ($reg_string_or_define) # 命令描述 $3
                    ,\s* ($reg_function) # 函数 $4
                    ,\s* ($reg_string_or_define) # 用法 $5
                    \s*\);
                /sgx) {
    my ($interface,$command,$descr,$function,$usage) = ($1,$2,$3,$4,$5);
    $command = resolve_str_or_define($command);
    $descr = resolve_str_or_define($descr);
    $usage = resolve_str_or_define($usage);
    warn "找到了非命令接口: $interface 的命令: $command" if ($interface ne "commands_api_interface");
    print "$command -- $descr -- $usage\n";
}
```

#### 3.1 `acl`

根据[访问控制列表 (ACL)](../Networking/3965687.mdx#-acl-)匹配 IP 地址。

##### 3.1.1 语法

**语法**

```xml
acl <ip_address> <acl_name>
```

##### 3.1.2 示例

**示例**

```xml
acl 1.2.3.4 test
```

#### 3.2 `alias`

为常用命令提供替代名称（即别名），以节省一些按键次数。

| 子命令    | 描述                         |
| ----------- | ------------------------------ |
| add        | 创建别名。                     |
| stickyadd  | 创建能在重启后保持的别名。 |
| del        | 删除别名。                     |

##### 3.2.1 语法

**语法**

```xml
alias add <alias> <command(s)>

alias stickyadd <alias> <command(s)>
```

```md
## 别名 del [<alias>|*]
```

##### 3.2.2 示例

**示例**

```xml
freeswitch> alias add reloadall reloadacl reloadxml
+OK

freeswitch> alias add unreg sofia profile internal flush_inbound_reg
+OK

freeswitch> alias stickyadd reloadall reloadacl reloadxml
+OK

freeswitch> alias del reloadall
+OK
```

#### 3.3 `bgapi`

在一个线程中执行 [API 命令](../Introduction/FreeSWITCH-API_30867723.mdx#-freeswitch--freeswitch-api-)。

##### 3.3.1 语法

**语法**

```xml
bgapi <command>[ <command_args>]
```
```

##### 3.3.2 示例

| 命令     | 描述                                                                                                                                                    | 语法                                                                                          | 示例                                                                                                                                                                                                                           |
| ---------| ---------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| acl      | 与 [访问控制列表 (ACL)](../Networking/3965687.mdx#-acl-) 匹配 IP 地址。                                                                                                                                                  | acl &lt;ip\_address> &lt;acl\_name>                                                           | acl 1.2.3.4 test                                                                                                                                                                                                              |
| alias    | 为常用命令提供一个备用名称 (即别名)，以节省一些按键次数在 [CLI](../Client-and-Developer-Interfaces/1048948.mdx#or) 上。子命令描述add创建一个别名stickyadd创建一个持久化的别名del删除别名                             | alias add &lt;alias> &lt;command(s)>alias stickyadd &lt;alias> &lt;command(s)>alias del \[&lt;alias>\|\*\] | freeswitch> alias add reloadall reloadacl reloadxml+OKfreeswitch> alias add unreg sofia profile internal flush\_inbound\_reg+OKfreeswitch> alias stickyadd reloadall reloadacl reloadxml+OKfreeswitch> alias del reloadall+OK |
| bgapi    | 在一个线程中执行一个 [API 命令](../Introduction/FreeSWITCH-API_30867723.mdx#-freeswitch--freeswitch-api-)。                                                    | bgapi &lt;command>\[ &lt;command\_args>\]                                                       |                                                                                                                                                                                                                               |
| complete | 完成。那个描述不太有帮助。                                                                                                                                  | complete add &lt;word>\|del \[&lt;word>|\*\]                                                    |                                                                                                                                                                                                                               |
| |        |                                                                                                                                                          |                                                                                                 |                                                                                                                                                                                                                               |
| |        |                                                                                                                                                          |                                                                                                 |                                                                                                                                                                                                                               |
| |        |                                                                                                                                                          |                                                                                                 |                                                                                                                                                                                                                               |
| |        |                                                                                                                                                          |                                                                                                 |                                                                                                                                                                                                                               |
| |        |                                                                                                                                                          |                                                                                                 |                                                                                                                                                                                                                               |

完整

完整。

使用方法：complete add&lt;单词>|del[&lt;单词>| *]

### cond

评估条件表达式。

用法：cond&lt;expr> ? &lt;true val> : &lt;false val>

`<expr>`支持的操作符有：

* `==`（等于）
* `!=`（不等于）
* `>`（大于）
* `>=`（大于等于）
* `<`（小于）
* `<=`（小于等于）

值是如何进行比较的？

* 两个字符串按字符串比较
* 两个数字按数字比较
* 字符串和数字按`strlen(string)`和数字进行比较

例如，`foo == 3`评估为真，而`foo == three`评估为假。

示例（点击展开）

示例：

**如果第一个值大于第二个值，则返回真**

```xml
cond 5 > 3 ? true : false
true
```

拨号计划中的示例：

```xml
<action application="set" data="voicemail_authorized=${cond(${sip_authorized} == true ? true : false)}"/>
```

稍微复杂一点的示例：

```xml
<action application="set" data="voicemail_authorized=${cond(${sip_acl_authed_by} == domains ? false : ${cond(${sip_authorized} == true ? true : false)})}"/>
```

  
关于语法的说明

问号和冒号周围的空格是必需的，自从[FS-5945](https://freeswitch.org/jira/browse/FS-5945)以来。在此之前，它们是可选的。如果缺少空格，`cond`函数将返回-ERR。

### domain_exists

检查FreeSWITCH域是否存在。

用法：domain_exists&lt;域>

### eval

评估（无操作）。评估字符串，展开变量。那些仅在呼叫会话期间设置的变量需要所需会话的uuid，否则返回“-ERR no reply”。

用法：eval [uuid:&lt;uuid> ]&lt;expression>

示例：

eval ${domain}
10.15.0.94

eval Hello, World!
Hello, World!

执行 uuid:e72aff5c-6838-49a8-98fb-84c90ad840d9 ${channel-state}
CS_EXECUTE

### 扩展

使用变量扩展来执行 [API 命令](../Introduction/FreeSWITCH-API_30867723.mdx#-freeswitch--freeswitch-api-)。

用法：expand [uuid:&lt;uuid> ]&lt;cmd> &lt;args>

示例：

expand originate sofia/internal/1001%${domain} 9999

在这个示例中，${domain} 的值被扩展。如果域名为"192.168.1.1"，则执行以下命令：

originate sofia/internal/1001%192.168.1.1 9999

### fsctl

向FreeSWITCH发送控制消息。

用法: fsctl  
  [  
  api_expansion [on|off] |  
  calibrate_clock |  
  debug_level [level] |  
  debug_sql |  
  default_dtmf_duration [n] |  
  flush_db_handles |  
  hupall |  
  last_sps |  
  loglevel [level] |  
  max_dtmf_duration [n] |  
  max_sessions [n] |  
  min_dtmf_duration [n] |  
  min_idle_cpu [d] |  
  pause [inbound|outbound] |  
  pause_check [inbound|outbound] |  
  ready_check |  
  reclaim_mem |  
  recover |  
  resume [inbound|outbound] |  
  save_history |  
  send_sighup |  
  shutdown [cancel|elegant|asap|now|restart] |  
  shutdown_check |  
  sps |  
  sps_peak_reset |  
  sql [start] |  
  sync_clock |  
  sync_clock_when_idle |  
  threaded_system_exec |  
  verbose_events [on|off]  
  ]

  
**fsctl 参数**

#### api_expansion

用法: fsctl api_expansion [on|off]

切换 API 扩展功能。关闭后，无法对通道变量进行类似 ${show channels} 的 [API 函数](../Introduction/FreeSWITCH-API_30867723.mdx#-freeswitch--freeswitch-api-) 扩展。这是一个不常用的特定安全模式。

#### calibrate_clock

用法: fsctl calibrate_clock

运行算法来计算实际需要休眠多长时间才能真正地休眠1毫秒。这只对那些没有timerfd的旧内核有用。在这些旧内核中，FS会自动检测到需要执行该计算。这个命令只是重复校准。

#### debug_level

用法: fsctl debug_level [level]

设置将发布到日志的调试信息量。1是较少冗长的，而9是更冗长的。其他调试消息将以ALERT日志级别发布。

0-致命错误，恐慌

1-关键错误，子系统层面的最小进展

2-非关键错误

3-警告，进度消息

5-信令协议动作（传入数据包，...）

7-媒体协议动作（传入数据包，...）

9-进入/退出函数，非常详细的进展


#### debug_sql

用法: fsctl debug_sql

每次调用此命令时，切换核心SQL调试消息的开关，打开或关闭。在繁忙的系统上谨慎使用。要查看所有消息，请在fs_cli界面上使用"logelevel debug"命令。

#### default_dtmf_duration

用法: fsctl default_dtmf_duration [int]

int = 时钟滴答数

示例:

fsctl default_dtmf_duration 2000

此示例将default_dtmf_duration开关参数设置为250毫秒。数字以时钟滴答数(CT)指定，其中duration(毫秒) = CT / 8或CT = duration * 8

default_dtmf_duration指定用于发起的DTMF事件或在没有指定持续时间的事件上使用的DTMF持续时间。此值在较低端由min_dtmf_duration限制，在较高端由max_dtmf_duration限制。因此，max_dtmf_duration >= default_dtmf_duration >= min_dtmf_duration。此值可以在switch.conf.xml中持久设置。

### **检查当前值:**

`fsctl default_dtmf_duration 0`

FS将持续时间为0视为状态检查。而不是将值设置为0，它只是返回当前值。

#### **flush_db_handles**

用法: `fsctl flush_db_handles`

清除核心数据库处理程序中的缓存数据库句柄。FreeSWITCH尽可能重用数据库句柄，但是在高负载的FS系统中，在高峰期间积累大量的数据库句柄，FS继续以FIFO方式分配新的数据库句柄来服务新的请求。`"fsctl flush_db_handles"`关闭不再需要的数据库连接，以避免超过数据库服务器的连接数。

#### **hupall**

用法: `fsctl hupall <clearing_type> dialed_ext <extension>`

断开到目标的现有呼叫并发送清除原因。

例如，要使用正常清除方式结束具有目标为分机1000的活动呼叫:

`fsctl hupall normal_clearing dialed_ext 1000`

#### **last_sps**

用法: `fsctl last_sps`

查询实际每秒会话数。

`fsctl last_sps`
`+OK last sessions per second: 723987253`
（实际情况可能会有所不同。）

#### **loglevel**

用法: `fsctl loglevel [level]`

指定日志消息在fs\_cli界面上显示时包含的详细程度。请参阅[mod\_console](./mod_console_1048950.mdx#about)来获取“level”的合法值和进一步讨论。

可用的日志级别可以用数字或名称指定:

0 - CONSOLE
1 - ALERT
2 - CRIT
3 - ERR
4 - WARNING
5 - NOTICE
6 - INFO
7 - DEBUG

#### **max_sessions**

用法: `fsctl max_sessions [int]`

设置FS允许多少个同时通话会话。这个值可以通过负载测试来确定，但受处理器速度和数量、网络和磁盘带宽、编解码器选择以及其他因素的影响。请参考 switch.conf.xml 中的持久设置 max-sessions。

#### max_dtmf_duration

用法：fsctl max_dtmf_duration [int]

默认值 = 192000 时钟滴答

示例：

fsctl max_dtmf_duration 80000

此示例将 max_dtmf_duration 开关参数设置为 10,000 毫秒（10 秒）。整数以时钟滴答（CT）的形式指定，其中 CT / 8 = 毫秒。max_dtmf_duration 限制了 DTMF 事件的播放时间为指定的持续时间。超过此持续时间的事件将被截断为此持续时间。不能配置超过此设置的持续时间。此设置可以降低，但不能超过 192000（默认值）。此设置不能低于 min_dtmf_duration。此设置可以在 switch.conf.xml 中持久地设置为 max-dtmf-duration。

查询当前值的方法：

fsctl max_dtmf_duration 0

FreeSWITCH 将 0 的持续时间识别为状态检查。它不会将值设置为 0，而是简单地返回当前值。

#### min_dtmf_duration

用法：fsctl min_dtmf_duration [int]

默认值 = 400 时钟滴答

示例：

fsctl min_dtmf_duration 800

这个例子将min\_dtmf\_duration开关参数设置为100毫秒。整数以时钟滴答数（CT）表示，其中CT / 8 = 毫秒。min\_dtmf\_duration指定了用于输出事件的最小DTMF持续时间。比这个时间短的事件将被增加到与min\_dtmf\_duration相匹配的持续时间。在配置文件中，不能将DTMF持续时间设置为低于此设置的配置文件。您可以增加此值，但不能将其设置为低于400（默认值）。该值不能超过max\_dtmf\_duration。可以在switch.conf.xml中持久设置此设置，作为min-dtmf-duration。

值得注意的是，许多设备在发送[RFC 2833](https://tools.ietf.org/html/rfc2833)时会压制嵌入式DTMF。压制嵌入式DTMF的设备具有一定的反应时间和卡顿时间，这有时可能高达40毫秒，但大多数情况下可以在20毫秒以下完成。当您的DTMF事件持续时间越接近此卡顿门槛时，DTMF被忽略为压制事件的风险就越大。如果您的呼叫始终是IP-IP的整个路径，这可能不是一个问题。然而，当您的呼叫发送到PSTN时，[RFC 2833](https://tools.ietf.org/html/rfc2833) DTMF事件必须在音频流中进行编码。这意味着线路中的其他设备（可能是您在呼叫的PBX或IVR）可能无法听到足够长以解码的DTMF音调，因此会完全忽略它们。因此，建议不要发送短于80毫秒的DTMF事件。

TODO [RFC 2833](https://tools.ietf.org/html/rfc2833)被[RFC 4733](https://tools.ietf.org/html/rfc4733)所取代。

检查当前值:

fsctl min\_dtmf\_duration 0

FreeSWITCH将0的持续时间视为状态检查。它不会将值设为0，而是直接返回当前的值。

#### min_idle_cpu

用法：fsctl min_idle_cpu [int]

分配最小CPU空闲时间的百分比，以供其他进程使用，以防止FreeSWITCH占用所有可用的CPU周期。

示例：

fsctl min_idle_cpu 10

这将分配最少10%的CPU空闲时间，不可用于FS的处理。一旦FS的CPU使用率达到90%，它将以503的cause code响应其他的SIP请求，直到自身使用率降到90%以下，同时保留机器上的最后10%供其他进程使用。

#### pause

用法：fsctl pause [inbound|outbound]

暂停接收入站或发起出站呼叫的能力，如果省略关键字，则同时暂停两个方向。执行fsctl pause inbound还会阻止处理注册请求。执行fsctl pause outbound将在FS日志中生成关键性的日志信息"The system cannot create any outbound sessions at this time"。

使用带有相应参数的resume来恢复正常操作。

#### pause_check

用法：fsctl pause_check [inbound|outbound]

如果指定的模式是活动状态，则返回true。

示例：

fsctl pause_check inbound
true

表示入站呼叫和注册已暂停。使用fsctl resume inbound来恢复正常操作。

fsctl pause_check
true

表示入站和出站会话都已暂停。使用fsctl resume来恢复正常操作。

#### ready_check

用法：fsctl ready_check

如果系统处于准备就绪状态，而不是等待优雅关机或其他不准备就绪的状态，则返回true。

#### reclaim_mem

用法：fsctl reclaim_mem

#### recover

用法：fsctl recover

向每个被检测到的可恢复通道发送特定于终结点的恢复命令。这取代了“sofia recover”，使得除SIP之外的多个终结点能够实现恢复。

#### resume

使用方法：fsctl resume [inbound|outbound]

暂停FreeSWITCH处理呼入、呼出或两个方向的通话后，恢复正常运行。

示例：

fsctl resume inbound
+OK

继续处理呼入呼叫和注册。请注意，此命令始终返回+OK，但必须使用与暂停命令中使用的关键字相对应的关键字才能生效。

#### save_history

使用方法：fsctl save_history

在预计执行可能导致FS崩溃的配置之前，写出命令历史记录。当调试新模块或脚本以允许其他开发人员查看崩溃前执行的命令时，这很有用。

#### send_sighup

使用方法：fsctl send_sighup

执行与使用UNIX kill命令杀死FS进程相同的操作，而无需使用UNIX kill命令。在像Windows这样没有kill命令的环境中非常有用，或者通过使用fs_cli -x "fsctl send_sighup"在cron或其他脚本中使用时，FS用户进程可能无权使用UNIX kill命令。

#### shutdown

使用方法：fsctl shutdown [asap|asap restart|cancel|elegant|now|restart|restart asap|restart elegant]

* cancel - 取消先前的关闭请求。
* elegant - 等待所有流量停止，同时允许新流量。
* asap - 等待所有流量停止，但不允许新流量。
* now - 立即关闭FreeSWITCH。
* restart - 在关闭后立即重新启动FreeSWITCH。

在提供“elegant”、“asap”或“now”时，还可以添加重启命令：

#### shutdown_check

用法：fsctl shutdown_check

如果FS正在关闭或正在关闭并重新启动，则返回true。

#### sps

用法：fsctl sps [int]

这会更改会话每秒限制的值，该值最初在switch.conf中设置。

#### sync_clock

用法：fsctl sync_clock

FreeSWITCH不会信任系统时间。它在首次启动时获取一个系统时间样本，然后在那个时刻之后使用单调时钟。您可以使用fsctl sync\_clock将其同步回系统实时时钟的当前值。

注意：fsctl sync\_clock会立即生效，这可能会影响到您的CDR时间。您可能会出现低计费/高计费，甚至是在呼叫发起前就挂断的情况。例如，如果FS的时钟偏差1个月，则您的CDR将显示持续了一个月的呼叫！

请查看fsctl sync\_clock\_when\_idle，它更安全。

#### sync_clock_when_idle

用法：fsctl sync_clock_when_idle

将FreeSWITCH时钟与主机机器的实时时钟同步，但要等到使用的通道数为0时再进行同步。这样就不会影响任何CDR。

#### verbose_events

用法：fsctl verbose_events [on|off]

启用详细事件。详细事件为特定通道的**每个**事件中的**每个**通道变量。非详细事件只在事件标头中包含预选通道变量。

请参阅[switch.conf.xml](https://wiki.freeswitch.org/wiki/Switch.conf.xml "Switch.conf.xml")以获取详细通道事件的持久设置。

#### global_getvar

获取全局变量的值。如果未提供参数，则获取所有全局变量。

用法：global_getvar [&lt;varname>]

#### global_setvar

设置全局变量的值。

用法：global_setvar &lt;varname>=&lt;value>

示例：

global_setvar outbound_caller_id=2024561000

### group

待办事项

### group_call

在 [调用组](../Directory/XML-User-Directory/index.mdx#groups) 中返回桥接字符串。

用法：group_call group@domain[+F|+A|+E]

+F 将以串行方式返回组成员，用 |（竖线）字符分隔

+A（默认）将以并行方式返回组成员，用逗号分隔

+E 将以 [企业方式](https://wiki.freeswitch.org/wiki/Freeswitch%5FIVR%5FOriginate#Enterprise%5Foriginate) 返回，用 :\_:（冒号 下划线 冒号）分隔

域名和可选标志之间没有空格。有关详细信息，请参阅 [XML User Directory](https://wiki.freeswitch.org/wiki/XML%5FUser%5FDirectory%5FGuide#Groups) 中的 [Groups](https://wiki.freeswitch.org/wiki/XML%5FUser%5FDirectory%5FGuide#Groups)。

请注意：如果您需要在 B 腿中设置传出用户变量，请确保您的域名或拨号组变量列表中没有 dial-string 和 group-dial-string；而是将 dial-string 或 group-dial-string 设置在用户的默认组中。这样，group\_call 将返回 user/101，并且 user/ 会将所有用户变量设置为 B 腿通道。

B 腿接收一个新变量 `dialed_group`，其中包含完整的组名称。

### help

显示所有 [API 命令](../Introduction/FreeSWITCH-API_30867723.mdx#-freeswitch--freeswitch-api) 的帮助信息。

用法：help

### host_lookup

对主机名执行 DNS 查询。

用法：host_lookup &lt;hostname>

### hupall

断开现有通道。

用法：hupall &lt;cause> [&lt;variable> &lt;value>]

所有设置了 &lt;variable> 为 &lt;value> 的通道将以 &lt;cause> 代码断开。

示例：

originate {foo=bar}sofia/internal/someone1@server.com,[sofia/internal/someone2@server.com](mailto:sofia/internal/someone2@server.com) &park

hupall normal_clearing foo bar

挂断交换机上的所有呼叫：

hupall system_shutdown

### in_group

确定用户是否是某个组的成员。

使用方法：in_group &lt;user>[@&lt;domain>] &lt;group_name>

### is_lan_addr

判断一个IP是否是局域网地址。

使用方法：is_lan_addr &lt;ip>

### json

JSON API

使用方法：json {"command" : "...", "data" : "..."}

**示例**

```bash
> json {"command" : "status", "data" : ""}
 
{"command":"status","data":"","status":"success","response":{"systemStatus":"ready","uptime":{"years":0,"days":20,"hours":20,"minutes":37,"seconds":4,"milliseconds":254,"microseconds":44},"version":"1.6.9 -16-d574870 64bit","sessions":{"count":{"total":132,"active":0,"peak":2,"peak5Min":0,"limit":1000},"rate":{"current":0,"max":30,"peak":2,"peak5Min":0}},"idleCPU":{"used":0,"allowed":99.733333},"stackSizeKB":{"current":240,"max":8192}}}
```

### load

加载外部模块

使用方法：load &lt;mod_name>

示例：

load mod_v8

### md5

返回给定输入数据的 MD5 哈希值

使用方法：md5 hash-key

示例：

md5 freeswitch-is-awesome  
765715d4f914bf8590d1142b6f64342e

### module_exists

检查是否已加载模块。

使用方法：module_exists &lt;module> 

示例：

module_exists mod_event_socket  
true

### msleep

休眠指定的毫秒数

使用方法：msleep &lt;number of milliseconds to sleep>

### nat_map

管理网络地址转换映射。

使用方法：nat_map [status|reinit|republish] | [add|del] &lt;port> [tcp|udp] [sticky] | [mapping] &lt;enable|disable>

* status - 提供NAT类型、外部IP和当前映射端口。
* reinit - 完全重新初始化NAT引擎。如果您更改了路由或将家用路由器从NAT模式更改为UPnP模式，请使用此选项。
* republish - 导致FreeSWITCH重新发布NAT映射。在正常操作中，这通常是不必要的。
* mapping - 控制是否向NAT发送端口映射请求（命令行选项`-nonatmap`可以在启动时禁用它）。这样可以在不打开NAT中的端口的情况下，仍然使用NAT获取公共IP的能力。

注意：sticky使映射在FreeSWITCH重新启动后保持不变。它为您提供了一个永久映射。

警告：如果在sip配置文件中定义了具有唯一IP地址的多个网络接口并使用相同的端口，当nat_map尝试为多个配置文件映射相同端口时，它将产生混淆。在sip_profiles中为公共地址和端口与私有地址和端口建立静态映射以避免此问题。

### regex

评估正则表达式。

用法：regex &lt;数据>|&lt;模式>[|&lt;替换字符串>][|(n|b)]
       regex m:/&lt;数据>/&lt;模式>[/&lt;替换字符串>][/(n|b)]
       regex m:~&lt;数据>~&lt;模式>[~&lt;替换字符串>][~(n|b)]

该命令的行为取决于是否提供了替换字符串和可选标志：

* 如果未提供`subst`，则正则表达式返回结果为"true"如果找到匹配项，否则返回"false"。
* 如果提供了`subst`，则在条件为true时，正则表达式返回`subst`的值。
* 如果提供了`subst`，并且条件为false（没有找到匹配项），正则表达式返回以下结果:
   * 原始字符串，没有标志；
   * 使用n标志，正则表达式返回null，强制回复 "-ERR no reply"；
   * 使用b标志，正则表达式返回"false"。

正则表达式的分隔符默认为 | (竖线) 字符。可以通过在正则表达式前加m:而将分隔符更改为\~ (波浪号) 或 / (正斜杠)：

示例:

regex test1234|\d                  &lt;== 返回"true"
regex m:/test1234/\d               &lt;== 返回"true"
regex m:~test1234~\d               &lt;== 返回"true"
regex test|\d                      &lt;== 返回"false"
regex test1234|(\d+)|$1            &lt;== 返回"1234"
regex sip:foo@bar.baz|^sip:(.*)|$1 &lt;== 返回"foo@bar.baz"
regex testingonetwo|(\d+)|$1       &lt;== 返回"testingonetwo"（没有匹配项）
regex m:~30~/^(10|20|40)$/~$1      &lt;== 返回"30"（没有匹配项）
regex m:~30~/^(10|20|40)$/~$1~n    &lt;== 返回"-ERR no reply"（没有匹配项）
regex m:~30~/^(10|20|40)$/~$1~b    &lt;== 返回"false"（没有匹配项）

在修订版14727中，如果源字符串与结果匹配，则条件为false，但是存在一次成功匹配，并且为1001。

regex 1001|/(^\d{4}$)/|$1

* 另请参阅 [正则表达式](https://wiki.freeswitch.org/wiki/Regular%5FExpression "Regular Expression")

### reload

重新加载模块。

用法：reload &lt;mod_name>

### reloadacl

在自动加载的配置文件`autoload_configs/acl.conf.xml`中修改访问控制列表后，重新加载ACL。在用户目录`conf/directory/\*.xml`中定义的扩展也会被重新加载。

用法：reloadacl [reloadxml]

### reloadxml

在修改配置文件后重新加载conf/freeswitch.xml设置。

用法：reloadxml

### show

显示各种报告，非常有用于故障排除和确认FreeSWITCH的正确配置。参数不能缩写，必须完整指定。

用法：show [  
   aliases（别名） |  
   api（API） |  
   application（应用程序） |  
   bridged_calls（桥接呼叫） |  
   calls [count]（呼叫） |  
   channels [count|like &lt;match string&gt;]（通道） |  
   chat（聊天） |  
   codec（编解码器） |  
   complete（完整） |  
   detailed_bridged_calls（详细桥接呼叫） |  
   detailed_calls（详细呼叫） |  
   dialplan（拨号计划） |  
   endpoint（端点） |  
   file（文件） |  
   interface_types（接口类型） |  
   interfaces（接口） |  
   limits（限制） |  
   management（管理） |  
   modules（模块） |  
   nat_map（NAT映射） |  
   registrations（注册） |  
   say（语音提示） |  
   tasks（任务） |  
   timer（计时器） |  
   ] [as xml（XML格式）|as delim &lt;delimiiter&gt;（以分隔符格式）]

XML格式：

show foo as xml

JSON格式：

show foo as json

**示例**

```bash
fs_cli -x "show channels as json" | jq
```

**示例输出**

```bash
{
  "row_count": 1,
  "rows": [
    {
      "uuid": "aa47bc9c-ab5e-11ea-85f1-311ce82e049e",
      "direction": "inbound",
      "created": "2020-06-10 17:09:26",
      "created_epoch": "1591823366",
      "name": "sofia/internal/1019@192.0.2.10",
      "state": "CS_EXECUTE",
      "cid_name": "1019",
      "cid_num": "1019",
      "ip_addr": "192.0.2.50",
      "dest": "55",
      "application": "echo",
      "application_data": "",
      "dialplan": "XML",
      "context": "default",
      "read_codec": "PCMU",
      "read_rate": "8000",
      "read_bit_rate": "64000",
      "write_codec": "PCMU",
      "write_rate": "8000",
      "write_bit_rate": "64000",
      "secure": "",
      "hostname": "hostname.local",
      "presence_id": "1019@192.0.2.10",
      "presence_data": "",
      "accountcode": "1019",
      "callstate": "ACTIVE",
      "callee_name": "",
      "callee_num": "",
      "callee_direction": "",
      "call_uuid": "",
      "sent_callee_name": "",
      "sent_callee_num": "",
      "initial_cid_name": "1019",
      "initial_cid_num": "1019",
      "initial_ip_addr": "192.0.2.50",
      "initial_dest": "55",
      "initial_dialplan": "XML",
      "initial_context": "default"
    }
  ]
}
```

更改定界符：

将foo显示为每行用|

* aliases - 列出已定义的命令别名
* api - 列出由可加载模块公开的[API命令](../Introduction/FreeSWITCH-API_30867723.mdx#-freeswitch--freeswitch-api-)
* application - 列出由可加载模块公开的应用程序，特别是mod\_dptools
* bridged\_calls - 已废弃，请使用"show calls"
* calls \[count\] - 列出当前活动通话的详细信息；关键字"count"表示仅打印通话总数，不包含详细信息
* channels \[count|like &lt;匹配字符串>\] - 列出当前通道；参见[通道 vs 通话](https://wiki.freeswitch.org/wiki/Channels%5Fvs%5FCalls)
   * count - 仅显示活动通道的数量，不包含详细信息
   * like &lt;匹配字符串> - 仅包含uuid、通道名称、cid\_number、cid\_name、presence数据字段中包含&lt;匹配字符串>的通道
* chat - 列出聊天接口
* codec - 列出当前在FreeSWITCH中加载的编解码器
* complete - 列出命令参数完成表
* detailed\_bridged\_calls - 与"show detailed\_calls"相同
* detailed\_calls - 类似于"show calls"，但包含更多字段
* dialplan - 列出拨号计划接口
  TODO _这里应该更详细一些。我假设这将显示构建内存（或运行时）拨号计划的所有文件名，类似于“xmllocate dialplan”，但似乎只涉及XML源。实际上，它显示了当前配置为主拨号计划输入的可用接口，而且甚至不确定输出列表的顺序是否相关。_
* endpoint - 列出当前可用于FS的终端接口
* file - 列出支持的文件格式接口
* interface\_types - 列出所有接口类型及每种类型接口的摘要计数
* interfaces - 按类型列出所有可用接口，显示每个接口的模块
* limits - 列出数据库限制接口
* management - 列出管理接口
* module - 列举模块及每个模块的路径
* nat\_map - 列出网络地址转换映射
* registrations - 列举用户扩展注册
* say - 枚举可用的TTS（文本到语音）接口模块及支持的语言
* tasks - 列出FS任务
* timer - 列出定时器模块

#### 显示呼叫和通道的提示

了解所有显示呼叫/通道的最佳方法是使用它们并观察结果。要显示更多字段：

* show detailed\_calls
* show bridged\_calls
* show detailed\_bridged\_calls

这三个命令可以展示"show calls"显示的信息的扩展内容。请注意，"show detailed\_calls"替代了"show distinct\_channels"。它提供了类似但更详细的信息。还要注意，没有"show detailed\_channels"命令，但使用"show detailed\_calls"将得到相同的结果：FreeSWITCH通过使用"show detailed\_calls"来列出有关单向呼叫和桥接呼叫的详细信息，这在配置和故障排除FS时非常有用。

结果筛选

要仅筛选与特定uuid匹配或与特定呼叫相关的通道，请在桥接或发起应用程序中将presence\_data通道变量设置为唯一字符串。然后，您可以使用：

show channels like foo

仅列出感兴趣的通道。**like**指令将根据以下字段进行筛选：

* uuid
* 通道名称
* 呼叫方身份标识名称
* 呼叫方身份标识号码
* presence\_data

注意：**presence\_data**必须在建立通道之前在**bridge**或**originate**时设置。

### shutdown

停止FreeSWITCH程序。

用法：shutdown

这适用于本地控制台（在前台运行的FreeSWITCH）以及fs\_cli。要从API调用中关闭FS，应使用"fsctl shutdown"，它提供了多种选项。

从控制台或fs\_cli关闭将忽略参数并立即退出！

  
### status

显示当前FS状态。在邮件列表或IRC频道上提问时，提供非常有帮助的信息。

用法：status

```plaintext
freeswitch@internal> status
运行时间：17年20天10小时10分钟31秒571毫秒721微秒
FreeSWITCH（版本1.5.8b git 87751f9 2013-12-13 18:13:56Z 32位）已启动 &lt;!-- FS版本 -->
自启动以来创建了53987253个会话 &lt;!-- FS启动以来累计创建的通道总数 -->
当前活动会话数127个，峰值为127个，最近5分钟为253个 &lt;!-- 当前活动通道数 -->
每秒创建55个会话，最大限制为60个，峰值为55个，最近5分钟为253个 &lt;!--每秒创建的通道数，最大值设置在switch.conf.xml中 -->
最大会话数为1000个 &lt;!-- 在switch.conf.xml中设置 -->
最小空闲CPU时间0.00/97.71 &lt;!-- 拒绝新呼叫前保留的最小空闲CPU时间，设置在switch.conf.xml中 -->

### strftime_tz

显示格式化的时间，转换为特定时区的时间。查看/usr/share/zoneinfo/zone.tab获取Linux标准时区列表。

用法：strftime_tz &lt;时区> [格式字符串]

示例：

strftime_tz US/Eastern %Y-%m-%d %T

### unload

卸载外部模块。

用法：unload &lt;模块名>

### version

显示switch版本

用法：version [简短]

示例：

freeswitch@internal> version  
FreeSWITCH 1.5.8b+git ~20131213T181356Z~87751f9eaf~32bit (git 87751f9 2013-12-13 18:13:56Z 32位)

freeswitch@internal> version short  
1.5.8b 

### xml_locate

将活动的XML树或指定分支写入stdout。

用法：xml_locate [root | &lt;section> | &lt;section> &lt;tag> &lt;tag_attr_name> &lt;tag_attr_val>]

xml\_locate root将返回FreeSWITCH正在使用的所有XML
```

xml_locate &lt;section>：将返回与指定&lt;section>对应的XML

xml_locate directory
xml_locate configuration
xml_locate dialplan
xml_locate phrases

示例：

xml_locate directory domain name example.com

xml_locate configuration configuration name ivr.conf

### xml_wrap

将另一个[API command](../Introduction/FreeSWITCH-API_30867723.mdx#-freeswitch--freeswitch-api-)包装成XML。

用法：xml_wrap &lt;command> &lt;args>

## 呼叫管理命令

### break

已弃用。请参阅uuid_break。

### create_uuid

创建一个新的UUID并将其以字符串形式返回。

用法：create_uuid

### originate

发起新的呼叫。

**用法**

```xml
originate <call_url> <exten>|&<application_name>(<app_args>) [<dialplan>] [<context>] [<cid_name>] [<cid_num>] [<timeout_sec>]
```

  
FreeSWITCH将发起一个以Leg A为参数的呼叫到&lt;call_url>。如果该Leg在60秒内监控，则FS将继续搜索&lt;exten>在指定的dialplan中的扩展定义，否则执行紧随&和其参数之后的应用程序。

**发起呼叫参数**

#### 参数

* &lt;call\_url> 正在调用的URL。有关Sofia SIP URL语法的更多信息，请参见：[FreeSwitch端点Sofia](../Configuration/Sofia-SIP-Stack/index.mdx#syntax)
* 目的地，其中之一：
   * &lt;exten> 要在拨号计划中搜索的目标号码；请注意，注册的分机将无法使用此方式，而应使用`&bridge(user/xxxx)`代替
   * &&lt;application\_name>(&lt;app\_args>)
      * "&"表示后面是一个应用程序名称，而不是一个号码
      * (&lt;app\_args>)是可选的（并非所有应用程序都需要参数，例如park）
      * 最常用的应用程序名称包括：park，bridge，javascript/lua/perl，playback（remove mod\_native\_file）
      * 注意：使用单引号来传递带有空格的参数，例如`'&lua(test.lua arg1 arg2)'`
      * 注意：&与应用程序名称之间没有空格
* &lt;dialplan> 如果未指定，默认为'XML'。
* &lt;context> 如果未指定，默认为'default'。
* &lt;cid\_name> 发送给Leg A的主叫方ID名称。
* &lt;cid\_num> 发送给Leg A的主叫方号码。
* &lt;timeout\_sec> 超时时间（以秒为单位）；默认为60秒。

**呼叫变量**

#### 变量

这些变量可以添加到拨号字符串中的大括号内，并用逗号分隔。示例：

originate {sip_auto_answer=true,return_ring_ready=false}user/1001 9198

大括号内的变量必须用逗号分隔。

* group\_confirm\_key（组确认键）
* group\_confirm\_file（组确认文件）
* forked\_dial（分叉拨号）
* fail\_on\_single\_reject（单个拒绝时失败）
* ignore\_early\_media（必须在桥接或发起命令的Leg B中定义，以阻止Leg A听到远程回铃声）
* return\_ring\_ready（返回振铃准备）
* originate\_retries（发起重试次数）
* originate\_retry\_sleep\_ms（发起重试休眠时间（毫秒））
* origination\_caller\_id\_name（发起人呼叫者ID名称）
* origination\_caller\_id\_number（发起人呼叫者ID号码）
* originate\_timeout（发起超时时间）
* sip\_auto\_answer（SIP自动应答）

[发起相关变量的说明](https://wiki.freeswitch.org/wiki/Channel%5FVariables#Originate%5Frelated%5Fvariables "Channel Variables")

**发起示例**

#### 示例

您可以通过以下方式呼叫本地注册的SIP端点300并将呼叫停靠。请注意，此处使用的"profile"必须是300注册到该"profile"的那个。还要注意使用%而不是@来指示它是一个已注册的分机。

   originate sofia/example/300%pbx.internal &park()

或者，您可以将远程SIP端点连接到分机8600

   originate sofia/example/300@foo.com 8600

或者，您可以将远程SIP端点连接到另一个远程分机

   originate sofia/example/300@foo.com &bridge(sofia/example/400@bar.com)

甚至可以运行一个名为test.js的JavaScript应用程序

   originate sofia/example/1000@somewhere.com &javascript(test.js)

要运行带参数的JavaScript，必须用单引号括起来

   originate sofia/example/1000@somewhere.com '&javascript(test.js myArg1 myArg2)'

将通道变量设置为拨号字符串

   originate {ignore_early_media=true}sofia/mydomain.com/18005551212@1.2.3.4 15555551212

设置SIP头变量以在发起期间发送到另一个FS框

```xml
originate {sip_h_X-varA=111,sip_h_X-varB=222}sofia/mydomain.com/18005551212@1.2.3.4 15555551212
```

注意：您可以设置任何通道变量，甚至自定义变量。使用单引号来包含带有空格、逗号等的值。

```shell
originate {my_own_var=my_value}sofia/mydomain.com/that.ext@1.2.3.4 15555551212
originate {my_own_var='my value'}sofia/mydomain.com/that.ext@1.2.3.4 15555551212
```

如果您需要模拟呼叫的回铃音，请尝试以下操作：

```shell
originate {ringback=\'%(2000,4000,440.0,480.0)\'}sofia/example/300@foo.com &bridge(sofia/example/400@bar.com)
```

要为Leg A呼叫和Leg B桥接应用程序指定参数，请使用以下XML代码：

```xml
originate {'origination_caller_id_number=2024561000'}sofia/gateway/whitehouse.gov/2125551212 &bridge(['effective_caller_id_number=7036971379']sofia/gateway/pentagon.gov/3035554499)
```

如果您需要当通道处于"Ring-Ready"状态时立即返回呼叫，则使用以下命令：

```shell
originate {return_ring_ready=true}sofia/gateway/someprovider/919246461929 &socket('127.0.0.1:8082 async full')
```

有关更多信息，请访问以下链接：[return\_ring\_ready ](http://blog.godson.in/2010/12/use-of-returnringready-originate.html)

如果需要，您甚至可以为回铃音设置音乐：

```shell
originate {ringback=\'/path/to/music.wav\'}sofia/gateway/name/number &bridge(sofia/gateway/siptoshore/12425553741)
```

您可以在后台发起呼叫（异步）并播放一个带有60秒超时的消息。

```shell
bgapi originate {ignore_early_media=true,originate_timeout=60}sofia/gateway/name/number &playback(message)
```

您可以通过以下方式指定被发起呼叫的UUID：

- 使用create\_uuid生成需要使用的UUID。
- 这样，您可以使用uuid\_kill在被应答之前终止发起的呼叫。
- 如果指定`origination_uuid`，则整个会话中应答呼叫的UUID将保持一致。

```markdown
发起呼叫 {origination_uuid=...}user/100@domain.name.com

还有一个[事件列表#1.21CHANNEL\_UUID事件](../Introduction/Event-System/Event-List_7143557.mdx#121-channel_uuid-event)中也提到了 `origination_uuid`，与 `bridge` 命令一起使用，但是在那里找不到相关文档。

以下是一个将呼叫发起到回音会议（一个外部SIP URL）并将其桥接到本地用户电话的示例：

originate sofia/internal/9996@conference.freeswitch.org &bridge(user/105@default)

以下是将呼叫发起至与 'default' 上下文不同的扩展的示例（对于使用 context_1、context_2 等上下文的FreePBX需求）：

originate sofia/internal/2001@foo.com 3001 xml context_3

您也可以使用以下方式将呼叫发起至多个扩展：

originate user/1001,user/1002,user/1003 &park()

要将呼出呼叫放入会议中的早期媒体，可以使用以下任一方式（它们实际上是相同的）

originate sofia/example/300@foo.com &conference(conf_uuid-TEST_CON)
originate sofia/example/300@foo.com conference:conf_uuid-TEST_CON inline

有关“内联”拨号计划的更多详细信息，请参见[mod\_dptools: 内联拨号计划](./mod-dptools/6586667.mdx#about) 

在[此邮件列表帖子](http://lists.freeswitch.org/pipermail/freeswitch-users/2013-January/091769.html) 中可以找到在A端使用loopback和内联的示例

### 暂停

暂停&lt;uuid>播放用 uuid\_broadcast 开始的录制媒体。

**用法**

```xml
pause <uuid> <on|off>
```

将暂停设置为 "on" 会激活暂停功能，即暂停播放录制的媒体。将暂停设置为 "off" 会取消暂停功能，并在暂停时的相同点重新开始播放录制的媒体。
```

注意：成功时始终返回“-ERR no reply”，uuid 无效时返回“-ERR No such channel!”。

### uuid_answer

应答通道

**使用方法**

```xml
uuid_answer <uuid>
```

参见

* [mod\_dptools: answer](./mod-dptools/6586406.mdx#about)

### uuid_audio

通过媒体强联机调整通道上的音频级别或静音（读/写）。

**使用方法**

```xml
uuid_audio <uuid> [start [read|write] [[mute|level] <level>]|stop]
```

&lt;level> 在 -4 到 4 的范围内，0 为默认值。

对于 mute|level 参数，两者都需要提供 level：

```xml
freeswitch@internal> uuid_audio 0d7c3b93-a5ae-4964-9e4d-902bba50bd19 start write mute <level>
freeswitch@internal> uuid_audio 0d7c3b93-a5ae-4964-9e4d-902bba50bd19 start write level <level>
```

（此命令行为古怪。需要进一步测试以验证所有参数。- JB）

参见

* [mod\_dptools: 设置音频级别](./mod-dptools/6587102.mdx#note)

### uuid_break

退出发送到通道的媒体。例如，如果正在向通道播放音频文件，则发出 uuid\_break 将停止媒体，呼叫将在呼叫计划、脚本或控制呼叫的其他方式中继续进行。

用法：uuid_break &lt;uuid> [all]

如果使用了 **all** 标志，则会停止并从队列中删除所有排队等待播放到通道的音频文件/提示等，否则只会停止当前正在播放的媒体。

### uuid_bridge

桥接两个呼叫腿。

**使用方法**

```xml
uuid_bridge <uuid> <other_uuid>
```

uuid\_bridge 需要至少一个呼叫腿处于已接通状态。例如，一个通道被停泊，另一个通道正在主动通话中，对这两个通道执行 uuid\_bridge 将挂断现有通话，并将指定的通道桥接在一起。

mod\_dptools: bridge VS uuid\_bridge

<https://lists.freeswitch.org/pipermail/freeswitch-users/2014-September/108166.html>

### uuid_broadcast

在指定的uuid上执行任意的dialplan应用程序，通常是播放媒体文件。如果指定了文件名，则将其播放到通道中。要执行应用程序，请使用"app::args"语法。

**用法**

```xml
uuid_broadcast <uuid> <path> [aleg|bleg|both]
```

在选定的链路上执行应用程序，并可选择在之后挂断：

**用法**

```xml
uuid_broadcast <uuid> app[![hangup_cause]]::args [aleg|bleg|both]
```

以下是一些示例：

**示例**

```xml
uuid_broadcast 336889f2-1868-11de-81a9-3f4acc8e505e sorry.wav both
uuid_broadcast 336889f2-1868-11de-81a9-3f4acc8e505e say::en\snumber\spronounced\s12345 aleg
uuid_broadcast 336889f2-1868-11de-81a9-3f4acc8e505e say!::en\snumber\spronounced\s12345 aleg
uuid_broadcast 336889f2-1868-11de-81a9-3f4acc8e505e say!user_busy::en\snumber\spronounced\s12345 aleg
uuid_broadcast 336889f2-1868-11de-81a9-3f4acc8e505e playback!user_busy::sorry.wav aleg
```

### uuid_buglist

列出通道上的媒体错误。输出格式为XML。

**用法**

```xml
uuid_buglist <uuid>
```

**示例**

```bash
uuid_buglist c2746178-ab61-11ea-86b8-311ce82e049e
```

**示例输出**

```bash
<media-bugs>
 <media-bug>
  <function>session_record</function>
  <target>rtmp://domain.local/stream:teststream</target>
  <thread-locked>0</thread-locked>
 </media-bug>
</media-bugs>


```

  
### uuid_chat

发送聊天消息。

**用法**

```xml
uuid_chat <uuid> <text>
```

如果与会话&lt;uuid>关联的端点具有receive_event处理程序，则将发送此消息到该会话，并将其解释为即时消息。

### uuid_debug_media

**使用方法**

```xml
uuid_debug_media <uuid> <read|write|both|vread|vwrite|vboth> <on|off>
```

使用"read"或"write"来调试音频方向，或者使用"both"来调试两个方向的音频。以v为前缀来调试视频媒体。

uuid_debug_media会产生大量的数据。如果你从fs_cli中调用此命令，请做好准备。

**示例输出**

R sofia/internal/1003@192.168.65.3 b= 172 192.168.65.3:17668 192.168.65.114:16072 192.168.65.114:16072 pt=0 ts=2981605109 m=0  
W sofia/internal/1003@192.168.65.3 b= 172 192.168.65.3:17668 192.168.65.114:16072 192.168.65.114:16072 pt=0 ts=12212960 m=0  
R sofia/internal/1003@192.168.65.3 b= 172 192.168.65.3:17668 192.168.65.114:16072 192.168.65.114:16072 pt=0 ts=2981605269 m=0  
W sofia/internal/1003@192.168.65.3 b= 172 192.168.65.3:17668 192.168.65.114:16072 192.168.65.114:16072 pt=0 ts=12213120 m=0

#### 读取格式

"R %s b=%4ld %s:%u %s:%u %s:%u pt=%d ts=%u m=%d\\n"

其中的值为：

* switch_channel_get_name(switch_core_session_get_channel(session)),
* (long) bytes,
* my_host, switch_sockaddr_get_port(rtp_session->local_addr),
* old_host, rtp_session->remote_port,
* tx_host, switch_sockaddr_get_port(rtp_session->from_addr),
* rtp_session->recv_msg.header.pt,
* ntohl(rtp_session->recv_msg.header.ts),
* rtp_session->recv_msg.header.m

#### 写入格式

"W %s b=%4ld %s:%u %s:%u %s:%u pt=%d ts=%u m=%d\\n"

其中的值为：

* switch\_channel\_get\_name(switch\_core\_session\_get\_channel(session)),
* (long) bytes,
* my\_host, switch\_sockaddr\_get\_port(rtp\_session->local\_addr),
* old\_host, rtp\_session->remote\_port,
* tx\_host, switch\_sockaddr\_get\_port(rtp\_session->from\_addr),
* send\_msg->header.pt,
* ntohl(send\_msg->header.ts),
* send\_msg->header.m);

### uuid_deflect

通过发送REFER方法，将已接听的SIP呼叫从FreeSWITCH上偏转

用法：uuid_deflect &lt;uuid> &lt;sip URL>

uuid\_deflect等待来自对方的最终响应报告。它将该响应中的sip片段作为FreeSWITCH响应返回给uuid\_deflect。如果对方报告REFER成功，则FreeSWITCH将在通道上发起结束通话。 (\*)  

(\*) 从FreeSWITCH 1.10.7版本开始，引入了一个名为_sip\_refer\_continue\_after\_repl_y_的变量，如果为`True`，则在发送REFER消息后，当前通话将继续不变。这在测试rfc4579 REFER方法请求Focus添加新资源到会议时很有用。

**示例**

uuid_deflect 0c9520c4-58e7-40c4-b7e3-819d72a98614 sip:info@example.net

响应：

  Content-Type: api/response
  Content-Length : 30

  +OK: SIP/2.0 486 Busy Here

### uuid_displace

使用指定的音频文件&lt;file>替换目标&lt;uuid>的音频。

用法：uuid_displace &lt;uuid> [start|stop] &lt;file> [&lt;limit>] [mux]

参数：

* uuid = 此通话的唯一ID（参见“显示通道”）
* start|stop = 启动或停止此操作
* file = 音频源路径（.wav文件、shoutcast流等）
* limit = 在终止该位移前的秒数限制
* mux = 复用；将原始音频与“文件”混合在一起，即在文件播放时双方仍然可以互相交谈（如果音量不太大）
* loop = 循环播放音频源

要指定第5个参数“mux”或“loop”，您必须指定一个限制；如果不希望在回放时设定时间限制，则指定为0。对于“loop”，您必须始终指定为0。

**示例**

cli> uuid_displace 1a152be6-2359-11dc-8f1e-4d36f239dfb5 start /sounds/test.wav 60
cli> uuid_displace 1a152be6-2359-11dc-8f1e-4d36f239dfb5 stop /sounds/test.wav  
cli> uuid_displace 1a152be6-2359-11dc-8f1e-4d36f239dfb5 stop /sounds/test.wav 0 loop

  
### uuid_display

如果电话支持，更新电话上的显示。目前，一些SIP电话（包括Polycom和Snom）支持该功能。

用法：&lt;uuid> 名称|号码

请注意，呼叫者ID名称和呼叫者ID号码之间用管道字符分隔。

该命令使电话重新协商编解码器。SIP -> RTP数据包大小应设置为0.020秒。如果在Cisco SPA系列电话上设置为0.030，将导致DTMF延迟。当电话上按下DTMF键时，可以在fs\_cli上看到它们延迟4-6秒。

示例：

freeswitch@sidious> uuid_display f4053af7-a3b9-4c78-93e1-74e529658573 Fred Jones|1001

+OK Success

  
### uuid_dual_transfer

将通话的每个路由器转移到不同的目标。

用法：&lt;uuid> &lt;A-dest-exten>[/&lt;A-dialplan>][/&lt;A-context>] &lt;B-dest-exten>[/&lt;B-dialplan>][/&lt;B-context>]

### uuid_dump

转储会话的所有变量值。

用法：uuid_dump &lt;uuid> [format]

### uuid_early_ok

停止忽略早期媒体的处理，即当 ignore_early_media=true 时，停止忽略来自 Leg B 的早期媒体，并正常响应。

用法：`uuid_early_ok <uuid>`

### uuid_exists

检查给定的 UUID 是否存在。

用法：`uuid_exists <uuid>`

返回 true 或 false。

### uuid_flush_dtmf

清除队列中的 DTMF 数字。

用法：`uuid_flush_dtmf <uuid>`

### uuid_fileman

管理从音频文件播放到通道的音频。

用法：`uuid_fileman <uuid> <cmd:val>`

命令包括：

* speed:<+[step]>|<-[step]>
* volume:<+[step]>|<-[step]>
* pause (切换)
* stop
* truncate
* restart
* seek:<+[milliseconds]>|<-[milliseconds]> (1000ms = 1 秒, 10000ms = 10 秒)

例如向前搜索 30 秒：

uuid_fileman 0171ded1-2c31-445a-bb19-c74c659b7d08 seek:+3000

（或者在 bind_digit_action 中使用当前通道的 ${uuid}）

'pause' 参数是一个切换开关：第一次调用时会暂停播放，第二次调用时会恢复播放。

### uuid_getvar

从通道获取变量。

用法：`uuid_getvar <uuid> <varname>`

### uuid_hold

将通道放置在保持状态。

用法：

`uuid_hold <uuid> `          将呼叫保持
`uuid_hold off <uuid> `      关闭呼叫保持
`uuid_hold toggle <uuid> `   根据当前呼叫状态切换呼叫状态

### uuid_kill

重置指定的` <uuid>` 通道。

用法：`uuid_kill <uuid> [cause]`

如果未指定 cause code，则使用 NORMAL_CLEARING。

### uuid_limit

应用或更改指定 uuid 的限制。

用法：`uuid_limit <uuid> <backend> <realm> <resource> [<max>/[interval]] [number [dialplan [context]]]`

请参见[mod\_dptools: limit](./mod-dptools/3375201.mdx#db)

### uuid_media

将FreeSWITCH重新邀请到媒体路径之外：

用法：uuid_media [off] &lt;uuid>

将FreeSWITCH重新邀请回来：

用法：uuid\_media &lt;uuid>

### uuid_media_reneg

告诉通道发送一个带有可重新协商的新编解码器列表的重新邀请。

用法：uuid_media_reneg &lt;uuid> &lt;=>&lt;codec string>

示例：添加=PCMU将提供的编解码器字符串设为绝对值。

### uuid_park

挂起呼叫

用法：uuid_park &lt;uuid>

指定的通道将被挂起，呼叫的另一端将被断开。

### uuid_pre_answer

预接通道。

用法：uuid_preanswer &lt;uuid>

参见：[Misc.\_Dialplan\_Tools\_pre\_answer](./mod-dptools/6586998.mdx#about)

### uuid_preprocess

预处理通道

用法：uuid_preprocess &lt;uuid>

### uuid_recv_dtmf

用法：uuid\_recv\_dtmf &lt;uuid> &lt;dtmf\_data>

### uuid_send_dtmf

向&lt;uuid>发送DTMF数字

用法：uuid_send_dtmf &lt;uuid> &lt;dtmf digits>[@&lt;tone_duration>]

使用字符w表示延迟0.5秒，使用字符W表示延迟1秒。

默认音调持续时间为2000ms。

### uuid_send_info

向端点发送信息

用法：uuid_send_info &lt;uuid>

### uuid_session_heartbeat

用法：uuid_session_heartbeat &lt;uuid> [sched] [0|&lt;seconds>]

### uuid_set_media_stats

在uuid\_dump中启用显示各种音频、视频和文本媒体统计信息。

用法：uuid_set_media_stats &lt;uuid>

### uuid_setvar

在通道上设置变量。如果省略了value，则变量将被取消设置。

用法：uuid_setvar &lt;uuid> &lt;varname> [value]

拨号计划等效

```xml
<action application="set" data="<varname>=<value>"/> 
```

<!-- 例如： -->
<action application="set" data="playback_terminators=none"/> 

```
  
  
**示例**

```bash
uuid_setvar c2746178-ab61-11ea-86b8-311ce82e049e record_sample_rate 8000
```

###   
uuid\_setvar\_multi

在通道上设置多个变量。

用法：uuid_setvar_multi &lt;uuid> &lt;varname>=&lt;value>[;&lt;varname>=&lt;value>[;...]]

### uuid_simplify

该命令指示FreeSWITCH安全地从SIP信令路径中移除自身。

用法：uuid_simplify &lt;uuid>

执行此[API命令](../Introduction/FreeSWITCH-API_30867723.mdx#-freeswitch--freeswitch-api-)以指示FreeSWITCH™检查Leg A和Leg B的网络地址。如果它们都由同一个交换机托管，这是通过转接或转发环路跨多个FreeSWITCH™系统实现的，则执行此命令的交换机将从SIP和媒体路径中移除自身，并将终端恢复到其本地FreeSWITCH™，以缩短网络路径。这在大型分布式FreeSWITCH™安装中特别有用。

例如，假设呼叫到达洛杉矶的FreeSWITCH™交换机，然后被接听，然后被转发到伦敦的FreeSWITCH™交换机，在那里被接听，然后被再次转发回洛杉矶。伦敦的交换机可以执行uuid\_simplify命令，告诉其本地交换机检查呼叫的两个腿，确定它们可以由洛杉矶的交换机托管，因为两个腿都是它本地的。另外，全局设置sip\_auto\_simplify为true，无论是在vars.xml文件中还是作为拨号计划扩展的一部分，都可以告诉FreeSWITCH对每个呼叫进行此检查，当两个腿监控时执行。

### uuid_transfer

待办事项：在 [mod\_commands](./mod_commands_1966741.mdx#--) 和 [mod\_dptools: transfer](./mod-dptools/6586616.mdx#about) 中的 `uuid_transfer` 有什么区别？

将现有呼叫转接到 &lt;dialplan> 和 &lt;context> 中的特定分机。Dialplan 可以是 "xml" 或 "directory"。

**用法**

```xml
uuid_transfer <uuid> [-bleg|-both] <dest-exten> [<dialplan>] [<context>]
```

可选的第一个参数允许您同时转接双方（-both）或仅对话与&lt;uuid>关联的一方（-bleg）。请注意，-bleg 实际上指的是 "另一腿"，当在实际 B 腿 uuid 上执行时，它将转接实际发起呼叫的 A 腿，并断开实际 B 腿。

注意：如果呼叫已经桥接，并且您想要转接呼叫的任一一方，则需要使用 &lt;action application="set" data="hangup\_after\_bridge=false"/>（或等效的 API）。如果未设置该值，转接将无法按预期工作，并将使呼叫处于混乱状态。

更多示例请参见 [内联拨号计划](../Dialplan/Inline-Dialplan_13173434.mdx#escaping)

### uuid_phone_event

向上游发送保持指示：

**用法**

```xml
uuid_phone_event <uuid> hold|talk
```

## 记录 / 播放命令

### uuid_record

将与给定 UUID 关联的通道的音频录制到文件中。start 命令会导致 FreeSWITCH 开始混合所有通话腿，并将结果以文件扩展名指定的格式保存为文件。stop 命令（如果可用）将停止录制并关闭文件。

这个 API 命令可能有问题，并且 "（如果可用）" 的备注可能暗指这一点：`uuid_record`似乎完全控制了（hijack）并且没有生成任何FreeSWITCH事件（无论是在`fs_cli`上还是通过事件套接字应用程序）。停止它的唯一方式是挂断电话（因为它似乎不遵守[playback_terminators](../../Channel-Variables-Catalog/playback_terminators_16353264.mdx#0-about)变量）。

请使用[mod_dptools:record](./mod-dptools/6587041.mdx#0-about)或[mod_dptools:record_session](./mod-dptools/6587110.mdx#about)代替。

如果媒体设置尚未发生，文件中将会包含静音音频，直到媒体可用。将会对被停放的呼叫进行录制。录音会在桥接的呼叫期间继续进行。如果呼叫设置在桥接后返回停放，则错误将保留在通话中，但在再次桥接之前不会录制音频。

TODO 如果媒体无法通过 FreeSWITCH 流过，会发出重新邀请吗？还是在这种情况下，我们只是无法获取音频流？

请参考与录制相关的通道变量[mod_dptools:record](./mod-dptools/6587041.mdx#0-about)。另一个值得注意的模块是[mod_dptools:record_session](./mod-dptools/6587110.mdx#about)。

**语法**

```text
uuid_record <uuid> [start|stop|mask|unmask] <path> [<limit>]
```

| 参数       | 描述                                                                                                                                                                                                                                                                                                                                                                                       |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **uuid**   | 通道的 UUID。                                                                                                                                                                                                                                                                                                                                                                              |
| **start**  | 开始录制音频。                                                                                                                                                                                                                                                                                                                                                                             |
| **stop**   | 停止录制。可以使用 `&lt;path>` 来停止具有给定 UUID 的通道的所有录音。`uuid\_record &lt;uuid> stop all` 用于停止所有录音。                                                                                                                                                                                                                                                                        |
| **mask**   | 当执行该命令时，使用静音部分屏蔽录音开始时的掩码参数。请参阅 <http://jira.freeswitch.org/browse/FS-5269>。                                                                                                                                                                                                                                                                                      |
| **unmask** | 停止屏蔽并继续正常录制实时音频。请参阅 <http://jira.freeswitch.org/browse/FS-5269>。                                                                                                                                                                                                                                                                                                    |
| **path**   | 将录制保存到指定路径的文件中。如果只提供文件名，则将保存到通道变量 [sound\_prefix](../../Channel-Variables-Catalog/sound_prefix_16353267.mdx#sound_prefix) 或 [base\_dir](../../Channel-Variables-Catalog/base_dir_17170736.mdx#base_dir)（当未设置 [sound\_prefix](../../Channel-Variables-Catalog/sound_prefix_16353267.mdx#sound_prefix) 时）中。 |
| **limit**  | （可选）录制的最大持续时间（以秒为单位）。                                                                                                                                                                                                                                                                                                                                                 |

## 限制命令

更多信息请参考[限制命令](https://wiki.freeswitch.org/wiki/Limit#API)

### limit_reset

重置限制后端。

### limit_status

从限制后端获取状态。

### limit_usage

检索给定资源的使用情况。

### uuid_limit_release

通过一个减少资源使用量。

### limit_interval_reset

在下一个区间开始之前将区间计数器重置为零。

## 杂项命令

### bg_system

在后台执行系统命令。

用法：bg_system &lt;command>

### echo

将输入回显到控制台

用法：echo &lt;text to echo>

示例：

echo 这个文字将会出现
这个文字将会出现

### file_exists

测试文件名是否存在。

file_exists 文件名

示例：

freeswitch> file_exists /tmp/real_file
true
  
freeswitch> file_exists /tmp/missing_file
false

拨号计划用法示例：

**file\_exists 示例**

```xml
<extension name="play-news-announcements">
  <condition expression="${file_exists(${sounds_dir}/news.wav)}" expression="true"/>
    <action application="playback" data="${sounds_dir}/news.wav"/>
    <anti-action application="playback" data="${soufnds_dir}/no-news-is-good-news.wav"/>
  </condition>
</extension>
```

file\_exists 测试FreeSWITCH是否能看到该文件，但由于受限制的权限，该文件可能仍然无法读取。

**示例启动/停止录制到 rtmp**

```bash
uuid_record c2746178-ab61-11ea-86b8-311ce82e049e start rtmp://domain.com/stream:teststream

uuid_record c2746178-ab61-11ea-86b8-311ce82e049e stop rtmp://domain.com/stream:teststream
```

  
### find_user_xml

检查用户是否存在。与目录中找到的用户标签匹配，类似于[user\_exists](https://wiki.freeswitch.org/index.php?title=User%5Fexists&action=edit&redlink=1 "User exists (page does not exist)")，但返回目录中定义的用户的XML表示（类似于[user\_exists](https://wiki.freeswitch.org/wiki/Mod%5Fcommands#user%5Fexists "Mod commands")中显示的那样）。

用法: find_user_xml &lt;key> &lt;user> &lt;domain>

&lt;key> 引用目录中指定的键

&lt;user> 表示键的值

&lt;domain> 是用户所分配的域。

### list_users

列出配置在目录中的用户

用法:

list_users [group &lt;group>] [domain &lt;domain>] [user &lt;user>] [context &lt;context>]

示例:

freeswitch@localhost> list_users group default

userid|context|domain|group|contact|callgroup|effective_caller_id_name|effective_caller_id_number
2000|default|192.168.20.73|default|sofia/internal/sip:2000@192.168.20.219:5060|techsupport|B#-Test 2000|2000
2001|default|192.168.20.73|default|sofia/internal/sip:2001@192.168.20.150:63412;rinstance=8e2c8b86809acf2a|techsupport|Test 2001|2001
2002|default|192.168.20.73|default|error/user_not_registered|techsupport|Test 2002|2002
2003|default|192.168.20.73|default|sofia/internal/sip:2003@192.168.20.149:5060|techsupport|Test 2003|2003
2004|default|192.168.20.73|default|error/user_not_registered|techsupport|Test 2004|2004

+OK

搜索过滤器可以组合使用:

freeswitch@localhost> list_users group default user 2004

userid|context|domain|group|contact|callgroup|effective_caller_id_name|effective_caller_id_number
2004|default|192.168.20.73|default|error/user_not_registered|techsupport|Test 2004|2004

+OK

### sched_api

安排一个未来的[API调用](../Introduction/FreeSWITCH-API_30867723.mdx#-freeswitch--freeswitch-api-)。

**用法**

```xml
sched_api [+@]<time> <group_name> <command_string>[&]
```

&lt;time>是要执行命令的UNIX时间戳。如果前缀是 +，&lt;time>表示在执行命令之前要等待的秒数。如果前缀是 @，它将每&lt;time>秒周期性地执行命令；对于第一次执行，将在&lt;time>秒后执行。

&lt;group\_name>是生成事件中“Task-Group”的值。"none"表示没有分组的正确值。如果设置为通道的UUID（例如：${uuid}），当通道挂断时，任务将自动取消安排。

&lt;command\_string>是在计划时间执行的命令。

可以使用sched_del或unsched_api来撤销预定的任务或一组任务。

您可以将"&"符号附加到行的末尾，以便在自己的线程中执行此命令。

**示例**

```xml
sched_api +1800 none originate sofia/internal/1000%${sip_profile} &echo()
sched_api @600 check_sched log Periodic task is running...
sched_api +10 ${uuid} chat verto|fs@mydomain.com|1000@mydomain.com|Hello World
```

  
### sched_broadcast

将&lt;path>文件播放给特定的&lt;uuid>呼叫，预定在将来执行。

**用法**

```xml
sched_broadcast [[+]<time>|@time] <uuid> <path> [aleg|bleg|both]
```

安排在所选的（部分）腿上执行应用程序，并可选择挂断：

sched_broadcast [+]&lt;time> &lt;uuid> app[![hangup_cause]]::args [aleg|bleg|both]

&lt;time> 是命令应该执行的UNIX时间戳。如果前缀是 +，则&lt;time> 指定在执行命令之前等待的秒数。如果前缀是 @，则它将按照&lt;time> 秒的周期定期执行命令；对于第一次实例，它将在&lt;time> 秒后执行。

**示例**

```xml
sched_broadcast +60 336889f2-1868-11de-81a9-3f4acc8e505e commercial.wav both
sched_broadcast +60 336889f2-1868-11de-81a9-3f4acc8e505e say::en\snumber\spronounced\s12345 aleg
```

### sched_del

删除先前计划的组或任务ID

**用法**

```xml
sched_del <group_name|task_id>
```

这个参数可以是先前计划的任务组或来自`sched_api`的返回任务ID。

`sched_transfer`、`sched_hangup` 和 `sched_broadcast` 命令添加具有与通道UUID相同的组名的新任务。因此，使用通道UUID作为参数的 `sched_del` 将删除此通道的所有先前计划的挂机、转移和广播。

**示例**

```xml
sched_del my_group
sched_del 2
```

  
### sched_hangup

安排运行中的呼叫挂断。

**用法**

```xml
sched_hangup [+]<time> <uuid> [<cause>]
```

  
sched\_hangup +0 等同于 uuid\_kill

### sched_transfer

为运行中的呼叫安排转移。

**用法**

```xml
sched_transfer [+]<time> <uuid> <target extension> [<dialplan>] [<context>]
```

  
### stun

执行STUN查找。

用法：

stun &lt;stunserver>[:port]

示例：

stun stun.freeswitch.org

### system

执行系统命令。

用法：

system &lt;command>

&lt;command> 将传递给系统Shell，在那里它可能会被扩展或以您不期望的方式解释。如果不小心，这可能导致安全漏洞。例如，以下命令是危险的：

&lt;action application="system" data="log_caller_name ${caller_id_name}" />

如果一个恶意的远程呼叫者以“`rm -rf /`”设置他的呼叫者ID名称，您将无意中执行以下Shell命令：

log_caller_name; rm -rf /

这将是件糟糕的事情。

### time_test

运行一个测试以查看定时器抖动有多糟糕。如果指定了 `<count>`，则运行测试 `<count>` 次，否则使用默认的 count 10，并尝试休眠 `mss` 微秒。它返回实际的定时器持续时间以及平均值。

用法：

time\_test `<mss>` [count]

示例：

time_test 100 5

test 1 sleep 100 99
test 2 sleep 100 97
test 3 sleep 100 96
test 4 sleep 100 97
test 5 sleep 100 102
avg 98

### timer_test

运行一个测试以查看定时器抖动有多糟糕。与 time\_test 不同，这个测试使用实际的 FreeSWITCH 定时器基础设施进行定时器测试，并执行用于呼叫处理的计时器。

用法：

timer_test `<10|20|40|60|120>` [\<1..200>] [\<timer_name>]

第一个参数是定时器间隔。

第二个是测试迭代次数。

第三个是定时器名称；"show timers" 可以给出一个列表。

示例：

timer_test 20 3

Avg: 16.408ms Total Time: 49.269ms

2010-01-29 12:01:15.504280 [CONSOLE] mod_commands.c:310 Timer Test: 1 sleep 20 9254
2010-01-29 12:01:15.524351 [CONSOLE] mod_commands.c:310 Timer Test: 2 sleep 20 20042
2010-01-29 12:01:15.544336 [CONSOLE] mod_commands.c:310 Timer Test: 3 sleep 20 19928

### tone_detect

在通道上启动音调检测。

用法：

```sh
tone_detect <uuid> <key> <tone_spec> [<flags> <timeout> <app> <args>] <hits>
```

当作为API调用执行时，需要 `<uuid>`；作为拨号计划应用时，uuid 是作为通道变量的一部分隐含的。

- `<key>` 是用来标识此音调检测实例的任意名称；必填项
- `<tone_spec>` 要检测的频率；必填项
- `<flags>` 'r' 或 'w'，用于指定监视的方向
- `<timeout>` 持续时间，用于检测音调；

0 = 持续检测

+time = 在 tone\_detect 执行后的毫秒数

time = 自纪元时 (1970年1月1日) 起的绝对时间，以秒为单位停止

- `<app>` 当 tone\_detect 被触发时执行的 FS 应用程序；如果省略 app，则只返回一个事件
- `<args>` 应用程序的参数，用单引号括起来
- `<hits>` 在执行指定的 app 之前，tone\_detect 应该触发的次数

一旦 tone\_detect 返回结果，它将不会再次触发，直到重置。通过调用 `tone_detect <key>` 来重置 tone\_detect，不带额外的参数即可重新激活先前指定的 tone\_detect 声明。

另请参阅 <https://freeswitch.org/confluence/display/FREESWITCH/mod%5Fdptools%3A+tone%5Fdetect>

### unsched_api

取消预定的 [API 命令](../Introduction/FreeSWITCH-API_30867723.mdx#-freeswitch--freeswitch-api-)。

**用法**

```xml
unsched_api <task_id>
```

### url_decode

用法：

url_decode &lt;string>

### url_encode

对字符串进行 URL 编码。

用法：

url_encode &lt;string>

### user_data

从 FreeSWITCH 用户目录中检索用户信息（参数或变量）。

用法：

user_data &lt;user>@&lt;domain> &lt;attr|var|param> &lt;name>

&lt;user> 是用户的 ID

&lt;domain> 是用户的域

&lt;attr|var|param> 指定请求的数据是否包含在用户记录的 "variables" 或 "parameters" 部分中

&lt;name> 是要检索的变量的名称（键）

示例：

user_data 1000@192.168.1.101 param password

将返回1234的结果，而

user_data 1000@192.168.1.101 var accountcode

将返回示例用户在[user\_exists](https://wiki.freeswitch.org/wiki/Mod%5Fcommands#user%5Fexists "Mod commands")中显示的1000的结果，以及

user_data 1000@192.168.1.101 attr id

当为该用户设置了number-alias="1000"属性时，将返回用户的实际字母数字ID（即"john"）。

### user_exists

检查用户是否存在。匹配在目录中找到的用户标签，并返回true/false：

用法：

```sh
user_exists <key> <user> <domain>
```

`<key>`是指定在目录的用户标签中的键

`<user>`表示键的值

`<domain>`是用户所属的域

示例：

user_exists id 1000 192.168.1.101

将返回true，如果目录中存在一个名为id的键，其值等于1000：

**用户目录条目**

```xml
    <user id="1000" randomvar="45">
        <params>
          <param name="password" value="1234"/>
          <param name="vm-password" value="1000"/>
        </params>
        <variables>
          <variable name="accountcode" value="1000"/>
          <variable name="user_context" value="default"/>
          <variable name="effective_caller_id_name" value="Extension 1000"/>
          <variable name="effective_caller_id_number" value="1000"/>
        </variables>
    </user>
```

在上面的例子中，我们也可以测试randomvar：

user_exists randomvar 45 192.168.1.101

我们会得到相同的true结果，但是：

user_exists accountcode 1000 192.168.1.101

或者

user_exists vm-password 1000 192.168.1.101

将返回false。

## 参见

* [通道变量](../Dialplan/Channel-Variables_16352493.mdx#about)

### 评论：

| SWITCH_ADD_API(commands_api_interface, "json", "JSON API", json_function, "JSON"); 我在`mod_commands.c`中找到了 **json** api，但我不知道它的用法。有没有示例？谢谢。![](/images/icons/contenttypes/comment_16.png) 由livem在2017年1月17日07:09发布                                               |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 命令 "**show calls**" 不支持 "like &lt;匹配字符串>"**show channels like** &lt;匹配字符串>能支持吗？![](/images/icons/contenttypes/comment_16.png) 由livem在2017年11月2日21:33发布                                                                                                                                                                                                                          |
| 使用 `uuid_getvar` 函数时，请注意使用正确的变量名。下面是一个有效的示例：`uuid_getvar my_uuid direction`。但是下面的示例将**无法工作**：`uuid_getvar my_uuid Call-Direction`。请参考[通道变量](../Dialplan/Channel-Variables_16352493.mdx#about)获取**通道变量名称**，
而不是 Info 变量名称！![](/images/icons/contenttypes/comment_16.png) 由Fx在2020年8月25日05:12发布 |
