# mod_curl

## 关于

这个应用程序可以让你发送一个HTTP请求并接收响应。输出可以是纯文本（可选的带有头部）或者一个JSON对象。

点击这里展开目录

- [设置和配置](#设置和配置)
- [应用程序](#应用程序)
- [CLI / API](#CLI / API)
- [Lua使用](#Lua使用)

## 设置和配置

为了使用mod_curl，你需要告诉FreeSWITCH在编译时添加这个模块，编辑`/usr/src/freeswitch/trunk`下的`modules.conf`文件并取消注释：

```xml
#applications/mod_curl
```

现在重新编译FreeSWITCH。

```xml
make
make install
```

通过将该模块添加到`/usr/local/freeswitch/conf/autoload_configs`目录下的`modules.conf.xml`文件，告诉FreeSWITCH在运行时实际使用curl模块：

```xml
<load module="mod_curl"/>
```

mod_curl没有单独的配置文件。

现在加载FreeSWITCH！

mod_curl为以下两个方面提供了API调用和拨号计划应用程序：

- curl - 允许您从Web服务器查询任意数据
- curl_sendfile - 允许您将任意数据和任意附加数据元素传输到Web服务器/REST，并可选择接收报告。

## 应用程序

curl应用程序的语法是：

```xml
<action application="curl" data="url [headers | json] [get | head | post [url_encode_data]]"/>
```

curl应用程序设置变量**curl_response_data**和**curl_response_code**。如果请求的话，**curl_response_data**也可以是头部/正文或者json。

```xml
<action application="curl" data="http://www.google.com"/>
<action application="info"/>
<action application="curl" data="http://www.google.com headers"/>
<action application="info"/>
<action application="curl" data="http://www.google.com json"/>
<action application="info"/>
```

curl\_sendfile的语法有两个选项：

```xml
<action application="curl_sendfile" data="<url> <filename_post_name=/path/to/filename [nopost|foo1=bar1&foo2=bar2&...fooN=barN [event|none [uuid|identifier]]]"/>
```

或者使用通道变量的方法示例：

```xml
<action application="set" data="curl_sendfile_report=event"/>
<action application="set" data="curl_sendfile_url=http://www.mydomain.com/test_files.php"/>
<action application="set" data="curl_sendfile_filename_element=myFile"/>
<action application="set" data="curl_sendfile_filename=/tmp/somefile.dmp"/>
<action application="set" data="curl_sendfile_extrapost=foo1=bar1&foo2=bar2&testing=a%20pain%20in%20the%20rear"/>
<action application="set" data="curl_sendfile_identifier=1234567890"/>
<action application="curl_sendfile"/>
```

您需要对\_url、\_filename和\_extrapost通道变量或data=""参数进行urlencode。如果您在data=""参数上调用应用程序并提供参数，如果您没有其他附加的post元素要添加并希望在data行上指定更多参数，必须指定'nopost'。如果为标识符指定'uuid'，应用程序将自动使用会话的uuid作为此值。

## 命令行/ API

CLI使用api接口。curl API调用的语法是：

```xml
curl url [headers|json|content-type <mime-type>|connect-timeout <seconds>|timeout <seconds>] [get|head|post|delete|put [data]]
```

从命令行中发出：

```xml
curl http://www.google.com
```

这将返回Google的主页。

```xml
curl http://www.google.com/ headers
```

将给您返回标题，然后是正文，而

```xml
curl http://www.google.com/ json
```
将给您返回Json格式数据。

会以结构化的 JSON 流形式提供标题和正文。

发送 POST 和 GET 请求。

```xml
curl http://www.myhost.com/?get=myGetValue
curl http://www.myhost.com post post=myPostValue%20a%20space
```

与标题或 JSON 混合。

```xml
curl http://www.myhost.com/?get=myGetValue json
curl http://www.myhost.com headers post post=myPostValue%20a%20space
```

curl\_sendfile API 调用的语法是：

```xml
[api/bgapi] curl_sendfile <url> <filenameParamName=filepath> [nopost|postparam1=foo&postparam2=bar... [event|stream|both|none  [identifier ]]]
```

**&lt;url> ：** 这是要发送到的 REST 的 URL 编码 URL。它应包含所需的所有 GET 参数，例如处理的特定脚本或应用程序 URL。

&lt;filenameParamName=filepath> ：这是一个键=值对。键是您希望标记此 POST 表单元素的名称。值是要传输到此 POST 表单元素的文件的完整路径。

**nopost|postparam1=foo&postparam2=bar... ：** 如果您希望指定其他一组文本 POST 表单元素，可以提供包含它们的 URL 编码的键=值对字符串。键是 POST 表单元素的标签，值是要绑定的实际值。因此，要创建名为 jabba 的 POST 元素，并将其值设置为 nobotha，请指定 jabba=nobotha。附加的 POST 元素必须使用 & 分隔键=值对，就像在 GET 请求中一样。如果您不想附加额外的 POST 元素，请直接指定 nopost。

**event|stream|both|none :** 该参数将决定如何以及在哪里显示来自REST的输出。如果指定为`event`，它将将输出附加到一个名为`curl_sendfile::ack`的自定义事件并触发。如果指定为`stream`，它将输出到活动流（即从中执行调用的方法）。如果指定为`both`，它将使用输出触发自定义事件，并显示到活动流中。如果指定为`none`，除了显示`+HTTP_STATUS_CODE Ok`或`-HTTP_STATUS_CODE Err`之外，不会显示任何输出。

**identifier：** 这个参数只是一个任意的标识符，供您自己使用。它只适用于`curl_sendfile::ack`事件，并在事件头部显示为`Command-Execution-Identifier`。您可以使用此值来跟踪命令的结果，以获取完成或错误状态。

如果您希望提供标识符值，您必须提供前面的两个可选参数，否则您的命令将无法正确解析。如果指定了提供事件的报告方法，则自定义事件的名称为`curl_sendfile::ack`。

## Lua使用方法

**注意：** 在进行诸如HTTP请求之类的长时间函数调用之前，最好检查`session:ready()`以便使您的脚本能够尽快停止运行并释放其资源，以避免卡死。

这是一个GET请求的示例：

```xml
session:execute("curl", "http://www.myhost.com/?name1=value1&name2=value2")
curl_response_code = session:getVariable("curl_response_code")
curl_response      = session:getVariable("curl_response_data")
```

这是一个POST请求的示例：

```xml
session:execute("curl", "http://www.myhost.com/ post name1=value1&name2=value2")
curl_response_code = session:getVariable("curl_response_code")
curl_response      = session:getVariable("curl_response_data")
```

这个例子展示了如何配置超时时间（以秒为单位）：

```xml
session:setVariable("curl_timeout", "10")
session:execute("curl", "http://www.myhost.com/ post name1=value1&name2=value2")
```

您也可以使用API接口：

```xml
api = freeswitch.API();
get_response = api:execute("curl", "http://www.myhost.com/?name1=value1&name2=value2")
post_response = api:execute("curl", "http://www.myhost.com/ post name1=value1&name2=value2")
```

在上述所有例子中，提交的数值必须进行[URL编码](http://en.wikipedia.org/wiki/Url%5Fencoding)。

提交：

```xml
first  = "a short value"
second = "a slightly longer value"
```

格式如下：

```xml
first=a%20short%20value&second=a%20slightly%20longer%20value
```

这个例子展示了一种编码参数以生成GET/POST请求的方法：（或者使用[CGILua的urlcode](http://keplerproject.github.com/cgilua/reference.html#urlcode)）

```xml
-- Lua uriencode function
--
-- 可以接受一个表格，或者一个由逗号分隔的字符串。
-- 示例：
-- > print(uriencode("this=is,a=/test/,string='quotes'"))
-- a=%2Ftest%2F&string=%27quotes%27&this=is
-- > print(uriencode({this="is", a="/test/", string="'quotes'"}))
-- a=%2Ftest%2F&string=%27quotes%27&this=is
--
function uriencode(vals)

    function escape (s)
        s = string.gsub(
            s,
            '([\r\n"#%%&+:;<=>?@^`{|}%\\%[%]%(%)$!~,/\'])',
            function (c)
                return '%'..string.format("%02X", string.byte(c));
            end
        );
        s = string.gsub(s, "%s", "+");
        return s;
    end
```

```lua
-- 定义一个编码函数
function encode(t)
    local s = "";
    for k, v in pairs(t) do
        s = s .. "&" .. escape(k) .. "=" .. escape(v);
    end
    return string.sub(s, 2); -- 去掉第一个&
end

-- 判断参数vals的类型
if type(vals) == 'table' then
    return encode(vals); -- 如果是table类型，直接调用encode函数进行编码
else
    local t = {}; -- 创建一个空表
    for k, v in string.gmatch(vals, ",?([^=]+)=([^,]+)") do -- 使用正则表达式提取键值对
        t[k] = v; -- 将键值对添加到表中
    end
    return encode(t); -- 调用encode函数进行编码
end
end
```

如果想要进行基本认证，则可以这样操作：

```lua
local auth_url = "http://username:password@mysecure_web_service.com"
local response = api:execute("curl", auth_url)
```

### Comments:
```text
这段代码定义了一个编码函数encode，用于将table或字符串进行编码。根据传入的参数vals的不同类型，分别进行处理。如果vals是table类型，直接调用encode函数进行编码；如果vals是字符串类型，则使用正则表达式提取键值对，然后再调用encode函数进行编码。最后，给出了一个示例，展示了如何进行基本认证的操作。
```

| 如何使用**curl**应用程序或CLI/API添加HTTP头？例如，在Linux curl中：curl -H 'header-name:value' http://www.google.com ![](/images/icons/contenttypes/comment_16.png) 发布者：livem 于 2016年12月27日02:00                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 在邮件列表上找到了这个，并希望将其包含在文档中。使用JSON发送POST请求。<http://localhost/faxapp> 内容类型为 'application/JSON'，提交 {"session\_id":"9dea8e0d880ec5b0450c2a96766b87","source":"1234XXXXXXX","destination":"56475XXXXXXX"} ![](/images/icons/contenttypes/comment_16.png) 发布者：aqsyounas 于 2017年2月3日15:35                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 这对我有用：freeswitch@pbx> curl <https://user:password@api.flowroute.com/v2/messages> 内容类型为 application/json，提交 '{ "to":"5551212", "from":"5551000", "body":"You have a voicemail message." }'(实际上，当我在一个新的Debian机器上切换到FreeSWITCH 1.6时，它停止了发送正确的身份验证信息，但这是另外一回事。) ![](/images/icons/contenttypes/comment_16.png) 发布者：starnet 于 2017年3月28日15:41                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 当我试图在拨号计划中结合单引号和双引号时，我遇到了一些问题... 使用上一个示例进行如下操作：&lt;action application="curl" data="<http://localhost/faxapp> 内容类型为 'application/JSON'，提交 {"session\_id":"9dea8e0d880ec5b0450c2a96766b87","source":"1234XXXXXXX","destination":"56475XXXXXXX"}"因为双引号用于开始/结束数据变量和JSON的键：值，所以失败了，我尝试对它们进行转义，但拨号计划重新加载仍然失败。为了使这样的东西起作用，我做了以下事情：&lt;action application="set" data='post={"session\_id":"9dea8e0d880ec5b0450c2a96766b87","source":"1234XXXXXXX","destination":"56475XXXXXXX"}' inline="true"/> &lt;action application="curl" data="<http://localhost/faxapp> 内容类型为 'application/json'，提交 ${post}" inline="true"/>注意：在"set"中，我用单引号（红色）括起了data=，这样我就可以在json中使用双引号。希望对您有所帮助！ ![](/images/icons/contenttypes/comment_16.png) 发布者：joelsdc 于2017年4月18日21:35 |
