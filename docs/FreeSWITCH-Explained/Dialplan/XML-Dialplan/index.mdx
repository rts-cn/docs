# XML拨号计划

## 关于

XML拨号计划是FreeSwitch使用的默认拨号计划。XML可以轻松手动编辑，无需特殊工具，只需一个文本编辑器。

一般来说，[拨号计划](../index.mdx#0-about)用于将呼叫路由到一个端点，可以是传统的分机、语音邮件、交互式语音应答（IVR）菜单或其他兼容应用程序。拨号计划非常灵活。

拨号计划可以分为**上下文**，允许呼叫按照不同类型的呼叫路径进行处理。呼叫也可以转移到其他上下文。例如，您可以配置两个拨号计划：一个处理始于公共电话网络（[PSTN](http://en.wikipedia.org/wiki/Public%5Fswitched%5Ftelephone%5Fnetwork)）的呼叫，另一个处理始于内部分机的呼叫。在[FreeSWITCH默认（或原始）配置](../../Configuration/Default-Configuration_6587388.mdx#mod_vp8)中，示例拨号计划遵循同样的原则：将外部PSTN呼叫通过一些额外的审查（通过[conf/dialplan/public.xml](https://github.com/signalwire/freeswitch/blob/master/conf/vanilla/dialplan/public.xml)中的**`public`**上下文）后转交给内部拨号计划（通过[conf/dialplan/default.xml](https://github.com/signalwire/freeswitch/blob/master/conf/vanilla/dialplan/default.xml)中的**`default`**上下文）。

拨号计划上下文还可以让您在办公楼中与[多个租户](../../Examples/Multi-tenant_13173521.mdx#about)共用一个PBX。由于每个租户可能都有自己的一组（而且通常会有冲突的）分机、语音菜单等，将租户分别放在独立的拨号计划中以便于配置和维护是很合理的选择。

点击展开目录

* 1 [先决条件学习](#learning-prerequisites)
* 2 [学习目标](#dialplan-variables)
* 3 [总览](#the-10000-foot-view)
* 4 [入门示例](#introductory-example)
* 5 [呼叫计划配置目录结构](#dialplan-configuration-directory-structure-)
* 6 [基础概念](#beginning-concepts)
   * 6.1 [上下文](#context)
   * 6.2 [扩展](#extensions)
   * 6.3 [条件](#conditions)
   * 6.4 [动作和反动作](#actions-and-anti-actions)
   * 6.5 [呼叫计划变量](#dialplan-variables)
* 7 [高级概念](#advanced-concepts)
   * 7.1 [嵌套条件](#nested-conditions)
   * 7.2 [执行时的行顺序 vs 嵌套顺序](#line-order-vs-nested-order-during-execution)
* 8 [示例库](#example-library)
* 9 [示例](#dialplan-variables)
   * 9.1 [示例1：匹配条件](#example-1-matching-a-condition)
   * 9.2 [示例2：匹配多个条件 (AND)](#example-2-matching-multiple-conditions-and-)
   * 9.3 [示例3：去掉前导数字](#example-3-stripping-leading-digits)
   * 9.4 [示例4：添加前缀](#example-4-adding-a-prefix)
   * 9.5 [示例5：SIP配置文件（使用不同的配置拨号）](#example-5-sip-profiles-dialing-with-different-configurations-)
   * 9.6 [示例6：呼叫已注册用户](#example-6-calling-registered-user)
   * 9.7 [示例7：在动作失败时执行故障转移](#example-7-action-failover-on-failed-action)
   * 9.8 [示例8：检查用户是否已验证](#example-8-check-user-is-authenticated)
   * 9.9 [示例9：将DID路由到分机](#example-9-routing-did-to-an-extension)
   * 9.10 [示例10：将呼叫路由到带有自定义呼叫者ID的网关分机](#example-10-route-to-a-gateway-extension-with-custom-caller-id)
   * 9.11 [示例11：基于号码前缀进行路由](#example-11-route-based-on-number-prefix)
   * 9.12 [示例12：处理无匹配分机的呼叫](#example-12-handle-calls-which-match-no-extension)
   * 9.13 [示例13：呼叫筛选](#example-13-call-screening)
   * 9.14 [示例14：媒体录音](#example-14-media-recording)
   * 9.15 [示例15：报时钟](#example-15-speaking-clock)
   * 9.16 [示例16：阻止特定代码](#example-16-block-certain-codes)
   * 9.17 [示例17：接收来自入站DID的传真](#example-17-receive-fax-from-inbound-did)
   * 9.18 [示例18：对入站BRI呼叫的effective_caller_id_number添加国际呼叫前缀](#example-18-add-international-call-prefix-to-effective_caller_id_number-on-incoming-bri-calls)
   * 9.19 [示例20：修复无效的呼叫者ID](#example-20-fix-invalid-caller-id-)
   * 9.20 [示例21：阻止出站呼叫者ID](#example-21-block-outbound-caller-id-)
   * 9.21 [示例22：在进行数据库查询时播放MOH](#example-22-play-moh-while-doing-a-database-lookup-)

### 学习先决条件

了解本文档需要了解 [正则表达式] (../../Examples/Regular-Expression/index.mdx#42x)。XML 拨号计划在字段上使用常见的 Perl 兼容正则表达式 (PCRE) 匹配语法，这减少了创建和维护拨号计划时的“学习曲线”。

只要具备对 PCRE 语法的工作知识，就能创建简单的拨号计划。

对于较复杂的 XML 拨号计划的作者来说，深入了解 PCRE 以及脚本或编程语言中使用的变量和流控制的工作知识将会很有益处。

### 学习目标

阅读本文档后，您应该能够：

* 向 Sofia **SIP 配置文件** 中添加一个配置语句，以调用 XML 拨号计划。
(有关 SIP 配置文件的详细信息，请参阅 [配置 FreeSWITCH#SIPProfiles sip-profiles] (../../Configuration/Configuring-FreeSWITCH/index.mdx#configuration-files)、[Sofia 配置文件](../../Configuration/Sofia-SIP-Stack/Sofia-Configuration-Files_7144453.mdx#--)、[Sofia SIP Stack](../../Configuration/Sofia-SIP-Stack/index.mdx#faq)、[mod_sofia](../../Modules/mod_sofia_1048707.mdx#about) 页面。)
* 使用正则表达式创建一个较复杂的 XML 拨号计划，将一个包含1000个扩展的拨号计划缩减为一个扩展定义。
* 理解条件和嵌套条件的流程修改功能，以及它们在拨号计划中的实用性。

单击此处展开目录

* 1 [学习前提条件](#学习前提条件)
* 2 [学习目标](#拨号计划变量)
* 3 [总览](#总览)
* 4 [简单示例](#简单示例)
* 5 [拨号计划配置目录结构](#拨号计划配置目录结构-)
* 6 [入门概念](#入门概念)  
   * 6.1 [上下文](#上下文)  
   * 6.2 [扩展](#扩展)  
   * 6.3 [条件](#条件)  
      * 6.3.1 [示例1：捕获数字](#示例1捕获数字)  
         * 6.3.2 [示例2：逻辑和](#示例2逻辑和)  
         * 6.3.3 [示例3：逻辑或](#示例3逻辑或)  
         * 6.3.4 [示例4：逻辑异或](#示例4逻辑异或)  
   * 6.4 [动作和反动作](#动作和反动作)  
      * 6.4.1 [反动作](#反动作)  
   * 6.5 [拨号计划变量](#拨号计划变量)  
      * 6.5.1 [访问变量](#拨号计划变量)
* 7 [高级概念](#高级概念)  
   * 7.1 [嵌套条件](#嵌套条件)  
   * 7.2 [线路顺序与嵌套顺序执行](#线路顺序与嵌套顺序执行)  
      * 7.2.1 [break="on-true"](#breakon-true)  
         * 7.2.2 [break="never"](#breaknever)  
         * 7.2.3 [Asterisk模式匹配](#Asterisk模式匹配)
* 8 [示例库](#示例库)  
   * 8.1 [呼叫者配置字段与频道变量](#呼叫者配置字段与频道变量)  
   * 8.2 [动作和反动作](#动作和反动作)  
   * 8.3 [可用动作](#拨号计划变量)  
   * 8.4 [内联动作](#内联动作)  
   * 8.5 [完整语法](#完整语法)  
   * 8.6 [总结](#总结)  
   * 8.7 [其他拨号计划的经验之谈](#其他拨号计划的经验之谈)  
   * 8.8 [自动查找](#自动查找)  
   * 8.9 [通过网关拨号](#通过网关拨号)
* 9 [示例](#拨号计划变量)  
   * 9.1 [示例1：匹配条件](#示例1匹配条件)  
   * 9.2 [示例2：匹配多个条件（和）](#示例2匹配多个条件和-)  
   * 9.3 [示例3：去除前导数字](#示例3去除前导数字)  
   * 9.4 [示例4：添加前缀](#示例4添加前缀)  
   * 9.5 [示例5：SIP配置文件（使用不同配置进行拨号）](#示例5sip配置文件使用不同配置进行拨号-)  
   * 9.6 [示例6：呼叫已注册用户](#示例6呼叫已注册用户)  
   * 9.7 [示例7：动作的故障转移](#示例7动作的故障转移)  
   * 9.8 [示例8：检查用户是否已验证](#示例8检查用户是否已验证)  
   * 9.9 [示例9：将DID路由到分机](#示例9将did路由到分机)  
   * 9.10 [示例10：使用自定义呼叫方标识路由到网关分机](#示例10使用自定义呼叫方标识路由到网关分机)  
   * 9.11 [示例11：基于号码前缀进行路由](#示例11基于号码前缀进行路由)  
   * 9.12 [示例12：处理无法匹配的呼叫](#示例12处理无法匹配的呼叫)  
   * 9.13 [示例13：呼叫筛选](#示例13呼叫筛选)  
   * 9.14 [示例14：媒体录制](#示例14媒体录制)  
   * 9.15 [示例15：报时功能](#示例15报时功能)  
   * 9.16 [示例16：阻止某些代码](#示例16阻止某些代码)  
   * 9.17 [示例17：从入站DID接收传真](#示例17从入站did接收传真)  
   * 9.18 [示例18：在呼入BRI呼叫中向effective_caller_id_number添加国际呼叫前缀](#示例18在呼入bri呼叫中向effective_caller_id_number添加国际呼叫前缀)  
   * 9.19 [示例20：修复无效的呼叫者ID](#示例20修复无效的呼叫者ID-)  
   * 9.20 [示例21：阻止出站呼叫方标识](#示例21阻止出站呼叫方标识-)  
   * 9.21 [示例22：在进行数据库查找时播放MOH](#示例22在进行数据库查找时播放MOH-)  
      * 9.21.1 [拨打SIP URI](#拨打sip-uri)  
         * 9.21.2 [拨打已注册用户](#拨打已注册用户)  
         * 9.21.3 [通过网关拨打（SIP提供商）](#通过网关拨打sip提供商)  
         * 9.21.4 [使用特定传输方式拨号](#使用特定传输方式拨号)  
         * 9.21.5 [指定编解码器](#指定编解码器)  
         * 9.21.6 [高级PortAudio设置](#高级portaudio设置)  
         * 9.21.7 [更改SIP Contact用户](#更改sip-contact用户)  
         * 9.21.8 [使用自定义SIP URI](#使用自定义sip-uri)  
         * 9.21.9 [使用命令行测试拨号计划](#使用命令行测试拨号计划)  
         * 9.21.10 [设置SIP转移标头以进行呼叫转接](#设置sip转移标头以进行呼叫转接)

## 10000英尺视角

此概览使用[Sofia](../../Configuration/Sofia-SIP-Stack/index.mdx#faq) SIP驱动程序[mod_sofia](../../Modules/mod_sofia_1048707.mdx#about)作为呼叫处理的起点和终点（即端点）。其他驱动程序有类似的机制。

当呼叫到达FreeSWITCH™ PBX时，Sofia是第一个响应者。她收集有关呼叫的信息，并决定要调用哪个拨号计划。

Sofia将有关呼叫的信息传递给您的拨号计划中的**[通道变量](../Channel-Variables_16352493.mdx#about)**，您的拨号计划使用这些变量来决定如何处理呼叫。通道变量包含有关正在处理的呼叫的丰富信息。例如，`destination_number`变量包含呼叫方拨打的号码。其他变量包含呼叫的呼叫者ID信息、呼叫者的源IP地址等。

XML拨号计划组织为一系列扩展定义（称为**扩展**）。FreeSWITCH™逐个扩展定义步进，直到找到匹配的扩展为止。

匹配是通过评估扩展内部的条件定义（称为**条件**）来执行的。FreeSWITCH™逐个步进扩展内的每个条件。

当扩展的条件满足时，将执行扩展的动作定义（称为**动作**）。在最简单的情况下，动作可以是将呼叫连接到物理分机。当然，在拨号计划中您可以执行各种各样的操作。在本概述中，我们将仅使用其中一些。

如果您的扩展的条件不满足，则可以执行可选的动作定义（称为“反动作”）。

当然，这只是开始使用XML拨号计划所需的基本概念。如果您熟悉其他编程或脚本语言，XML拨号计划提供了逻辑操作和控制流选项，可以让您创建复杂的拨号计划。但不要认为XML拨号计划能解决所有问题。复杂的XML拨号计划有时很难阅读和理解，这就是为什么还有其他拨号计划处理器可用的原因。话虽如此，XML拨号计划是一个很好的起点，在处理呼叫时通常可以完成大部分工作。

### 初级示例

以下示例显示了一个拨号计划，它只知道如何将呼叫路由到两个分机，500和501。但在使用之前，您需要告诉SIP驱动程序拨号计划的名称（称为“上下文”），以便在需要处理呼叫时使用。

**conf/sip_profiles/example.xml**

```xml
<profile name="example_sip_profile">
    <param name="context" value="example"/>
    ...其他配置语句...
</profile>
```

下面是示例拨号计划的代码。

**conf/dialplan/example.xml**

```xml
<context name="example">
    <extension name="500">
        <condition field="destination_number" expression="^500$">
            <action application="bridge" data="user/500"/> 
        </condition>
    </extension>
 
    <extension name="501">
        <condition field="destination_number" expression="^501$">
            <action application="bridge" data="user/501"/>
            <action application="answer"/>
            <action application="sleep" data="1000"/>
            <action application="bridge" data="loopback/app=voicemail:default ${domain_name} ${dialed_extension}"/>
        </condition>
    </extension>
</context>
```

当一个呼叫需要处理时，FreeSWITCH™会对呼叫路由表中的每个分机进行逐一评估，直到找到匹配的分机。

在我们的示例中，第一行定义了上下文块。该块中的所有项目属于“example”呼叫路由上下文。上下文块中嵌套了分机块，包含匹配的“条件”和相应的“动作”规则。分机按照它们在配置文件中出现的顺序进行处理。

在本示例中，当Sofia接收到一个传入的SIP呼叫后，呼叫路由将开始执行。下面是接下来的步骤：

* 首先评估第一个分机块，由于目标号码与“500”不完全匹配，该块的剩余部分被跳过。
* 接下来评估第二个分机块。目标号码完全匹配“501”，导致条件下的动作被执行。在本示例中，分机501响铃。如果分机没有接听，第二个动作将接听呼叫，并且随后的动作延迟1000毫秒（1秒），然后将呼叫连接到语音邮件系统。

需要注意的事项：

* 在例子中找到将呼叫传递到语音信箱的动作。注意`domain_name`和`dialed_extension`这两个通道变量的值是如何传递给语音信箱应用程序的。您可以在自己的拨号计划中像这样引用通道变量。

* 当呼叫被桥接到另一个分机或者被移交给另一个拨号计划时，拨号计划会自动停止处理其他动作和扩展。这意味着在我们的例子中，如果501分机接听，呼叫结束后，其余的动作将不会被执行。

* 为数千个分机创建这样的拨号计划将会很繁琐，也不够高效。阅读完这篇文档后，您会如何使用只有一个分机定义来构建一个包含1000个分机的拨号计划呢？

### 拨号计划配置目录结构

在`${conf_dir}/dialplan/`下查找：

FreeSWITCH的"原始"配置将拨号计划存储在`${conf_dir}/dialplans/`目录中，其中每个上下文都存储在其子目录中。这是推荐的配置方式。

例如，这个示例结构存储了一个简单PBX的拨号计划：

**拨号计划层次结构**

```text
freeswitch/
    conf/
        dialplans/
            public.xml
            public/
                00_security_screen.xml
                10_inbound_sip-bandwidth-r-us.xml
                29_inbound_sip-super-call.xml
                ...
            default.xml
            default/
                00_feature_codes.xml
                05_voicemail_access.xml
                20_extension_2001.xml
                20_extension_2002.xml
```

注意事项：

*这个拨号计划结构类似于随 FreeSWITCH™ 一起提供的示例配置。这是一个良好的起点，可以根据自己的需要定制自己的 PBX，就像我们在这里所做的一样。
*在拨号计划目录中放置的任何 .xml 文件在 FreeSWITCH 启动时都会被加载。
*`public.xml` 包含了公共上下文的所有常见配置信息，然后包含了 public 目录中的所有 XML 文件。
*`default.xml` 包含了默认上下文的所有常见配置信息，然后包含了 default 目录中的所有 XML 文件。
*文件按照字母顺序加载，因此以数字开头的文件名是确保拨号计划的各个部分按照正确顺序加载的良好做法（如果需要的话）。

### 初步概念

#### 上下文（Context）

上下文是扩展的逻辑分组。

context 标签只有一个必需的参数，名为 name。这是传入呼叫处理程序（如 \[Sofia\] SIP 驱动程序）在需要路由呼叫时使用的名称。在典型的 PBX 拨号计划中通常会有多个上下文。还有一个保留名称，即 any，它与任何上下文匹配。

```xml
<context name="default">
    <!-- 一个或多个 extension 标签 -->
</context>
```


#### 扩展（Extension）

在每个上下文中可以有一个或多个扩展。扩展是呼叫的目的地。在 FreeSWITCH™ 中，扩展是呼叫路由的主要方式。不要被名称所迷惑，因为扩展不一定总是连接着真实的电话。扩展可以用于处理呼叫路由逻辑、安全限制、出站干线选择等。

扩展标签有一个必需的参数 name，并且必须是唯一的。其他拨号计划可以使用此名称将控制转移到您的拨号计划。

在一个扩展中，可能包含一个或多个条件。如果满足这些条件，则执行与该条件相关联的动作。如果不满足条件，则执行可选的反向动作。

例如：

**XML 扩展模板**

```xml
<extension name="在这里输入你的扩展名称">
  <condition/>
  <condition...
    <action .../>
    <anti-action .../>
  </condition>
</extension>
```

默认情况下，当在你的拨号计划中匹配到一个扩展时，将执行其中的动作，并停止拨号计划的处理。一个可选的“continue”参数允许你的拨号计划继续评估剩余的扩展：

**继续路由**

```xml
<extension name="500" continue="true">
```

#### 条件

条件是拨号计划中的核心部分。它们非常灵活，因此有时构造起来比较困难。本文档将从简单的例子开始，逐渐过渡到更复杂的例子。

条件允许你将正则表达式与每个呼叫关联的通道变量进行匹配。本文档中的第一个例子就是这样，它将目标号码与“500”进行匹配，如下所示。

```xml
<extension name="500">
    <condition field="destination_number" expression="^500$">
        <action application="bridge" data="user/500"/> 
    </condition>
</extension>
```

每个条件都是使用 Perl 兼容的正则表达式库进行解析的。（请参阅 [Perl 兼容的正则表达式](http://perldoc.perl.org/perlre.html) 文档以了解更多信息。）

##### 示例1：捕获数字

下一个示例将利用 PCRE 的一个特性，展示如何将本地呼叫路由到本地[电信/公共交换电话网](../../Introduction/Glossary_13173966.mdx#telco)。（当地运营商通常要求将本地呼叫剥离其国家/地区/城市代码。）

在美国，完整的11位电话号码的最后7位数字是本地部分。因此，如果我们的PBX位于洛杉矶，本地通话的前四位数字将始终为1213，因此我们可以检查这一点：

```xml
<condition field="destination_number" expression="^1213\d\d\d\d\d\d\d$">
```

该条件将匹配以"1213"开头的任何11位数字。为了捕获最后的7位数字，我们将它写成这样，将最后的7位数字放在括号中。

```xml
<condition field="destination_number" expression="^1213(\d\d\d\d\d\d\d)$">
```

该条件仍将匹配以1213开头的任何11位数字。添加的功能是现在可以在临时变量$1中获取号码的最后7位数字。现在，我们可以创建一个完整的拨号计划扩展，将所有本地通话转接给本地电信公司。

```xml
<extension name="local_calls">
    <condition field="destination_number" expression="^1213(\d\d\d\d\d\d\d)$">
        <action application="bridge" data="sofia/gateway/LocalTelco/$1"/>
    </condition>
</extension>
```

目标号码为12135551212的情况下，$1将被设置为5551212，然后将呼叫发送给本地电信公司。

在替换捕获的文本时要小心，特别是在构建号码时。也许本地电话公司要求所有本地通话的本地号码后面加上数字5。我们可能会写成"sofia/gateway/LocalTelco/$15"，但那是错误的。将变量括在大括号中可以消除歧义："sofia/gateway/LocalTelco/${1}5"。这适用于所有FreeSWITCH™变量，并且通常可以提高拨号计划的可读性。

##### 示例2：逻辑与

假设您想将分机号500的呼叫重定向到分机号531，但仅在星期日。

在英语中，您会这样说：“如果目标号码是500并且今天是星期日，则将呼叫转移到分机531，否则转移到分机500”。

在XML拨号计划中，您可以在一个分机中放置多个条件，并且所有条件必须匹配才能执行最终条件的操作。

下面是实现的方法：

```xml
<condition field="destination_number" expression="^500$"/>
<condition wday="1">
    <action application="bridge" data="sofia/internal/531@example.com"/>     # 星期日：转发呼叫。
    <anti-action application="bridge" data="sofia/internal/500@example.com"/>     # 不是星期日：正常处理。
</condition>
```

###### 需要注意的事项

* 在这里使用“anti-action”是为了确保如果最终条件失败，呼叫将转到正确的位置。
* 不要被误导：FreeSWITCH™不会评估所有条件以做出决定。这种设计模式之所以有效，是因为FreeSWITCH™会在第一个条件失败后停止处理分机。
* 请记住，在使用此结构时，必须遵守正确的XML语法。请确保关闭除最后一个条件之外的所有条件，使用"/>进行关闭。最后一个条件包含要运行的最终操作，并且在最后一个操作的下一行进行关闭。

##### 示例3：逻辑或

使用多个条件可以模拟许多编程语言中可用的逻辑或（OR）操作。在这种情况下，如果其中一个条件匹配，则执行操作。

有几种方法可以实现这一点。使用符合您需求的方法。

最简单的版本是使用一个正则表达式，将目标号码与501或502进行匹配：

```xml
<condition field="destination_number" expression="^501|502$">
    action(s)...
</condition>
```

如果您的OR条件使用相同的字段，这个方法效果很好。如果您需要使用两个或多个不同的字段，那么扩展正则表达式语法将会帮助解决问题：

```xml
 <condition regex="any">
  <regex field="some_field" expression="Some Value"/>
  <regex field="another_field" expression="^Another\s*Value$"/>
  <action(s) ...>
  <anti-action(s)...>
</condition>
```

请注意条件中的`regex="any"`。这意味着如果任何以下正则表达式语句匹配成功，那么将执行相应的操作。当然，如果所有的正则表达式都不匹配，则会执行相应的反操作（如果有的话）。下面是一个示例，如果来电者的姓名是“Some User”或被呼叫的分机是1001，则执行扩展的操作。

```xml
<extension name="Regex OR Example">
  <condition regex="any">
    <!-- 如果其中任何一个条件为真，则后续的操作将会被添加到执行列表中 -->
    <regex field="caller_id_name" expression="Some User"/>
    <regex field="caller_id_number" expression="^1001$"/>
    <action application="log" data="INFO 至少有一个条件匹配成功！"/>
    <!-- 如果*没有一个*正则表达式为真，则将会添加反操作到执行列表中 -->
    <anti-action application="log" data="WARNING 没有一个条件匹配成功！"/>
  </condition>
</extension> 
```

`<condition regex=...>`还有其他两个选项：`all`和`xor`。因此，完整的选项如下：

* regex="any" — 我们在上面使用了它。条件中包含的任何正则表达式都可以匹配执行相应的操作。
* regex="all" — 等同于逻辑 AND 操作。条件中包含的所有正则表达式都必须匹配才能执行相应的操作。这是另一种执行逻辑 AND 的方式，就像我们在前一节中所做的那样。使用让拨号计划更清晰、更易于阅读的语法。
* regex="xor" — 等同于逻辑 XOR 操作。XOR 通常被称为“异或”，因为只有一个正则表达式必须匹配才能执行相应的操作。

动作和反动作的执行方式与标准条件块相同。

使用这种方法可以更轻松地匹配呼叫者的姓名或呼叫者 ID 号码，并在其中任一条件为真时执行操作。

以下是对该方法的稍微高级使用示例。如果呼叫者的姓名是“Michael S Collins”或呼叫者 ID 是 1002、3757 或 2816，则变量 calling\_user 被设置为“mercutioviz”。如果两者都不符合条件，则 calling\_user 变量被设置为“loser”。播放完欢迎消息后，根据 calling\_user 变量播放自定义消息。

```xml
<extension name="正则表达式OR示例2" continue="true">
  <condition regex="any" break="never">
    <regex field="caller_id_name" expression="^Michael\s*S?\s*Collins"/>
    <regex field="caller_id_number" expression="^1001|3757|2816$"/>
    <action application="set" data="calling_user=mercutioviz" inline="true"/>
    <anti-action application="set" data="calling_user=loser" inline="true"/>
  </condition>
 
  <condition>
    <action application="answer"/>
    <action application="sleep" data="500"/>
    <action application="playback" data="ivr/ivr-welcome_to_freeswitch.wav"/>
    <action application="sleep" data="500"/>
  </condition>

  <condition field="${calling_user}" expression="^loser$">
    <action application="playback" data="ivr/ivr-dude_you_suck.wav"/>
    <anti-action application="playback" data="ivr/ivr-dude_you_rock.wav"/>
  </condition>
</extension>  
```

注意，在设置`calling_user`变量的动作中增加了`inline="true"`选项。通常情况下，当FreeSWITCH™处理一个分机时，会将所有的动作集中起来，并在评估完所有条件之后执行它们。换句话说，在多个`<condition... />`语句的分机中，不能依赖于在条件全部评估完毕之前执行动作。

`inline="true"`选项会在第一个条件匹配时立即设置该变量。如果没有它，我们的示例将无法正常工作，因为在变量实际设置之前，将检查所有的条件块。这将使第三个条件块失效。

  
##### 示例4: 逻辑异或操作
```

我们已经看到了如何使用`regex=`子句来实现AND和OR的功能。为了完整起见，这里有一个最后的示例，展示了如何使用XOR。如果第一个或第二个正则表达式匹配，则执行操作，但如果两个都匹配则不执行。

```xml
 <extension name="Regex XOR example 3" continue="true">
  <condition regex="xor">
    <!-- If only one of these is true then the subsequent actions are added to execute list -->
    <regex field="caller_id_name" expression="Some User"/>
    <regex field="caller_id_number" expression="^1001$"/>
    <action application="log" data="INFO Only one of the conditions matched!"/>
    <!-- If *none* of the regexes is true then the anti-actions are added to the execute list -->
    <anti-action application="log" data="WARNING None of the conditions matched!"/>
  </condition>
</extension> 
```

#### 操作和反操作

扩展定义的最后部分是其操作。这些操作是让FreeSWITCH™代表你执行操作的，如连接呼叫或提供其他功能。可用的操作列表很长而且多样化，可以在[这里](../../Modules/mod_dptools_1970333.mdx#-c)找到。一些更有用的操作包括：

| 操作     | 描述                              |
| -------- | --------------------------------- |
| answer   | 接听电话                          |
| bridge   | 将呼叫桥接到另一个会话             |
| log      | 写入日志文件                      |
| hangup   | 断开电话连接                      |
| playback | 播放音频文件或音调流               |
| set      | 设置通道变量                      |
| transfer | 将呼叫转移到另一个扩展              |

这需要重申：动作不会与其绑定的条件"内联执行"。在执行任何动作之前，FreeSWITCH™ 会先检查扩展中的所有条件。在大多数情况下，您不能指望一个动作被执行并且其结果可用于检查（或在之后的&lt;condition...>或&lt;action...>中使用）。

在某些情况下，动作可能支持inline="true"选项，它会导致动作与其匹配的条件同时执行。并非所有拨号计划应用都支持此选项。设置应用程序可能是您最有可能使用此功能的地方，就像我们在 [此示例](#dialplan-variables) 中展示的那样。

##### 反动作

在我们的一些介绍性示例中，我们展示了`反动作（anti-action）`表达式的使用。顾名思义，当包含它们的条件求值为false时，将执行反动作。

对于每个条件，如果条件的动作未执行，则将执行反动作，反之亦然。

#### 拨号计划变量

到目前为止，您已经看到了拨号计划及其结构的基本组成部分。示例展示了以下基本用法：

* 扩展
* 条件
* 简单正则表达式
* 动作和反动作

我们只涉及了拨号计划变量的方面。它们是在 FreeSWITCH™ 拨号计划中执行任何有用操作所必需的。

变量是存储以供后续使用的命名信息片段。在拨号计划启动时，大量的信息会以变量的形式预加载。您可以使用正则表达式与变量匹配，并根据结果控制拨号计划的执行。

我们将介绍一些常用的变量，以巩固其正确使用，并演示FreeSWITCH™中的变量替换功能的一些特性。

##### 访问变量

在您的XML拨号计划中，有三种类型的变量可供您访问：

* * 通道变量  
   * 全局变量  
   * 内置变量（时间、日期等）

###### 通道变量

通道变量可用于获取有关呼叫的信息并**控制其行为**，以在拨号计划中逐步进行。通道变量包含大量关于正在处理的呼叫以及可设置的各种选项的信息。通过将变量名称用${ }括起来访问通道变量的内容。例如，要在拨号字符串的末尾附加默认SIP域，您只需在拨号字符串文本中引用`${domain_name}`，其值将自动替换：

```xml
    <action application="bridge" data="user/1000@${domain_name}/>
```

您可以像这样设置通道变量的值：

```xml
    <action application="set" data="call_timeout=30"/>
```

有关通道变量的完整列表和在拨号字符串中使用它们的其他方式，请参见：[通道变量](../Channel-Variables_16352493.mdx#about)。我们在这里只列出一个简短的列表，以让您了解可能的操作。

| 变量名                   | 描述                                                             |
| ----------------------- | ---------------------------------------------------------------- |
| caller\_id\_name        | 呼叫方的姓名                                                     |
| destination\_number     | 呼叫方拨打的号码                                                 |
| direction               | 该通话的方向是呼入还是呼出                                         |
| channel\_name           | 该通话的呼入通道名称，例如：sofia/sales/John\_Smith@192.168.1.1       |
| call\_timeout           | 设置等待通话接通的秒数，如果超过该时间将会放弃通话                      |
| state                   | 该通道的状态，例如 CS\_EXECUTE 或 CS\_HANGUP                          |
| bridge\_hangup\_cause   | 通话结束的原因，例如 NO\_ANSWER, NORMAL\_CLEARING 或 USER\_BUSY       |

###### 内建变量

通过名称访问内建变量，**不需要使用惯例的 $ 前缀**。

内建变量列表：（更新于2014年7月29日，switch_xml.c, switch_xml_std_datetime_check()）

| 内置名称                      | 描述                                                                                 |
| -------------------------- | ----------------------------------------------------------------------------------- |
| _标准日期和时间_                 |                                                                                     |
| date-time                 | 当前日期和时间：YYYY-MM-DD HH:MM:SS，例如：2014-08-12 15:34:59                              |
| time-of-day               | 当前本地时间：HH:MM:SS，例如：15:34:59                                                       |
| _日期和时间部分（基于本地时区）_     |                                                                                     |
| year                      | 当前年份。（1970 至 9999）                                                             |
| mon                       | 当前月份。（1 至 12）                                                                 |
| mday                      | 当前月份的日期。（1 至 31）                                                             |
| hour                      | 当前小时。（0 至 23）                                                                  |
| minute                    | 当前分钟。（0 至 59）                                                                  |
| _高级日期和时间部分_              |                                                                                     |
| wday                      | 当前星期几。（星期日为1，星期六为7）                                                         |
| week                      | 自1月1日起的当前周数。（1 至 53）                                                             |
| mweek                     | 当前月份的周数。（1 至 6）                                                              |
| yday                      | 当前年份的第几天。（1 至 366）                                                           |
| minday                    | 从午夜开始的当前分钟数。（0 至 1440）                                                      |
| tz-offset                 | 与 GMT 相比的时区偏移量，以小时为单位。（-11 至 +11）                                         |
| dst                       | 如果当前处于夏令时，则返回1；否则返回0。                                                       |

在条件语句中，您可以与多个内置变量进行比较。所有比较都必须匹配（逻辑与）后，才会执行其操作。

有多种方法与内置变量匹配。您可以：

| 类型        | 示例                     | 描述                           |
| ----------- | ------------------------ | ------------------------------ |
| 相等        | `<condition wday="1">`      | 是星期天吗？                     |
| 范围        | `<condition wday="2-4">`    | 是周一、周二还是周三？           |
| 列表        | `<condition wday="1,4"> `   | 是星期天还是星期三？             |
| 组合        | `<condition wday="1-3,7"> ` | 是星期天、星期一、星期二还是星期六？ |

范围操作也可以用于时间和日期。

```xml
<condition time-of-day="08:00:00-09:00:00">
<condition date-time="2010-10-01 00:00:01~2010-10-15 23:59:59">
```

日期的范围运算符为“**\~**”，**而不是**“–”。

### 高级概念

#### 嵌套条件

条件可以相互嵌套。嵌套条件很难，非常难以正确掌握。您可能想使用脚本替代（是的，您想使用脚本）。请参阅 [mod\_lua](../../Modules/mod_lua_1048944.mdx#--) 了解 Lua 脚本。

当主条件具有嵌套条件时，**首先会评估主表达式**，并将其主动作推入待办事项列表中，**然后评估嵌套条件**，并将其动作推入待办事项列表中。

每个条件都有一个隐含的参数“**require-nested**”，默认设置为“**true**”。

当我们的条件中设置了require-nested参数为"true"时，所有嵌套条件必须为true（[AND]其表达式必须为true），才能使整个条件为true。

如果"require-nested"设置为"false"，则只需表达式为true，无论嵌套条件如何，条件即为true。

条件会按照通常的方式进行检查（遵循"break"参数），并且将条件内的操作添加到TODO列表。

让我们看一个示例扩展，包含了可以进行测试的嵌套条件，检查所有可能的情况和边缘情况。

```xml
<extension name="nested_example">
    <condition field="destination_number" expression="^2901$" require-nested="false">
        <action application="log" data="ERR 00 CID号码是${caller_id_number}，CID名称是${caller_id_name}" />
        <action application="set" data="var_01=N/A" inline="true"/>
        <action application="set" data="var_02=N/A" inline="true"/>
        <action application="set" data="var_03=N/A" inline="true"/>
        <action application="set" data="var_04=N/A" inline="true"/>
        <action application="set" data="var_05=N/A" inline="true"/>
        <action application="log" data="ERR 01 我在前面..."/>
        <action application="set" data="var_01=01" inline="true"/>
        <action application="log" data="ERR 02 我在前面 ${var_01} ${var_02} ${var_03} ${var_04} ${var_05}"/>
        <condition field="caller_id_number" expression="1011" break="on-false">
            <action application="log" data="ERR 03 我是第一个的..."/>
            <action application="log" data="ERR 04 我是第一个CID号码是${caller_id_number}" />
            <action application="set" data="var_02=02" inline="true"/>
            <action application="log" data="ERR 05 我是第一个 ${var_01} ${var_02} ${var_03} ${var_04} ${var_05}"/>
        </condition>
        <action application="log" data="ERR 06 我在中间..."/>
        <action application="set" data="var_03=03" inline="true"/>
        <action application="log" data="ERR 07 我在中间 ${var_01} ${var_02} ${var_03} ${var_04} ${var_05}"/>
        <condition field="${caller_id_name}" expression="Giovanni" break="on-false">
            <action application="log" data="ERR 08 我是第二个的..."/>
            <action application="log" data="ERR 09 我是第二个CID名称是${caller_id_name}" />
            <action application="set" data="var_04=04" inline="true"/>
            <action application="log" data="ERR 10 我是第二个 ${var_01} ${var_02} ${var_03} ${var_04} ${var_05}"/>
        </condition>
        <action application="log" data="ERR 11 我在后面..."/>
        <action application="set" data="var_05=05" inline="true"/>
        <action application="log" data="ERR 12 我在后面 ${var_01} ${var_02} ${var_03} ${var_04} ${var_05}"/>
    </condition>
</extension>
<extension name="call_has_not_stopped_before_here">
    <condition field="destination_number" expression=".*">
        <action application="log" data="ERR 还没有停在这之前"/>
    </condition>
</extension>
```


你可以更改许多内容来测试这个例子：

* 显然，所有的"表达式": 2901, 1011, Giovanni
* 在第一个条件中，`require-nested` 可以设置为 "true" 或 "false"
* "set" 动作的 `inline` 参数可以设置为 "true" 或 "false"
* 嵌套条件的 `break` 参数可以设置为 "on-false"、"on-true"、"never" 或 "always"

根据你是如何嵌套条件的，你将得到一个嵌套顺序的结果或一个行顺序的结果。
请观察以下两个示例和每个示例的执行顺序。

#### 行顺序 vs 嵌套顺序的执行

![](/attachments/3966106/19595480.png)paste examples

点击这里展开...


```xml
<extension name="嵌套示例">
  <condition field="destination_number" expression="^2901$" require-nested="false">
    <action application="log" data="ERR 1 嵌套级别1a"/>
    <action application="log" data="ERR 2 嵌套级别1b"/>
    <condition field="${direction}" expression="inbound" break="never">
      <action application="log" data="ERR 3 嵌套级别2a"/>
      <action application="log" data="ERR 4 嵌套级别2b"/>
      <condition field="${direction}" expression="inbound" break="never">
        <action application="log" data="ERR 5 嵌套级别3a"/>
        <action application="log" data="ERR 6 嵌套级别3b"/>
      </condition>
      <action application="log" data="ERR 7 嵌套级别2c"/>
      <action application="log" data="ERR 8 嵌套级别2d"/>
    </condition>
    <action application="log" data="ERR 9 嵌套级别1c"/>
    <action application="log" data="ERR 10 嵌套级别1d"/>
  </condition>
</extension>
```

执行 verto.rtc/2901 log(ERR 1 嵌套级别1a)
执行 verto.rtc/2901 log(ERR 2 嵌套级别1b)
执行 verto.rtc/2901 log(ERR 9 嵌套级别1c)
执行 verto.rtc/2901 log(ERR 10 嵌套级别1d)
执行 verto.rtc/2901 log(ERR 3 嵌套级别2a)
执行 verto.rtc/2901 log(ERR 4 嵌套级别2b)
执行 verto.rtc/2901 log(ERR 7 嵌套级别2c)
执行 verto.rtc/2901 log(ERR 8 嵌套级别2d)
执行 verto.rtc/2901 log(ERR 5 嵌套级别3a)
执行 verto.rtc/2901 log(ERR 6 嵌套级别3b)

========================================================================================

```xml
<extension name="另一个嵌套示例">
  <condition field="destination_number" expression="^2902$" require-nested="false">
    <action application="log" data="ERR 1 Nest Level 1a"/>
    <action application="log" data="ERR 2 Nest Level 1b"/>
    <condition field="${direction}" expression="inbound" break="never">
      <action application="log" data="ERR 3 Nest Level 2a"/>
      <action application="log" data="ERR 4 Nest Level 2b"/>
    </condition>
    <condition field="${direction}" expression="inbound" break="never">
      <action application="log" data="ERR 5 Nest Level 3a"/>
      <action application="log" data="ERR 6 Nest Level 3b"/>
    </condition>
    <condition field="${direction}" expression="inbound" break="never">
      <action application="log" data="ERR 7 Nest Level 2c"/>
      <action application="log" data="ERR 8 Nest Level 2d"/>
    </condition>
    <condition field="${direction}" expression="inbound" break="never">
      <action application="log" data="ERR 9 Nest Level 1c"/>
      <action application="log" data="ERR 10 Nest Level 1d"/>
    </condition>
  </condition>
</extension>
```

执行 verto.rtc/2902 log(ERR 1 Nest Level 1a)
执行 verto.rtc/2902 log(ERR 2 Nest Level 1b)
执行 verto.rtc/2902 log(ERR 3 Nest Level 2a)
执行 verto.rtc/2902 log(ERR 4 Nest Level 2b)
执行 verto.rtc/2902 log(ERR 5 Nest Level 3a)
执行 verto.rtc/2902 log(ERR 6 Nest Level 3b)
执行 verto.rtc/2902 log(ERR 7 Nest Level 2c)
执行 verto.rtc/2902 log(ERR 8 Nest Level 2d)
执行 verto.rtc/2902 log(ERR 9 Nest Level 1c)
执行 verto.rtc/2902 log(ERR 10 Nest Level 1d)

  
高级条件/操作规则

##### break="on-true"

这是一个更复杂的示例，使用 `break="on-true"` 和 `break="on-false"` 语句为支持组织执行基于时间的路由。用户拨打分机号1100。实际的支持分机号是1105，在每天早上8点到晚上10点之间有人值班，除了星期五，那时有人值班从早上8点到下午1点。在其他所有时间，拨打1100的电话都会被发送到“非工作时间”语音信箱。

```xml
<extension name="Time-of-day">
	<condition field="destination_number" expression="^1100$" break="on-false"/>    <!--如果为 False，则 FreeSWITCH 跳到下一个扩展。-->
	<condition wday="6" hour="8-12" break="on-true">                                <!--如果为 True，则不再发起下一个条件集的评估。-->
		<action application="transfer" data="1105 XML default"/>                    <!--周五，上午8点到下午12点59分-->
	</condition>
	<condition wday="1-5" hour="8-21" break="on-true">                              <!--星期日至星期四，上午8点到晚上9点59分-->
		<action application="transfer" data="1105 XML default"/>
	</condition>
	<condition>                                                                    <!--这是一个全捕获条件，将呼叫发送到其他所有时间的语音信箱。-->
		<action application="voicemail" data="default ${domain} 1105"/>
	</condition>
</extension>
```

###### 注意事项

`break="on-true"` 语句会在条件测试评估为 True 时使扩展停止处理。在上面的示例中，如果呼叫在指定的支持时间内到达，呼叫将被转接，而其他条件**将不会被处理**。

如果未指定，将默认使用 `break="on-false"` 行为。


##### break="never"

在这个例子中，我们使用`break="never"`语句来导致第一个条件即使为假也总是"穿透"到下一个条件。这对于在扩展处理中设置各种标志非常有用。如果目标号码以1开头，这个例子将设置变量`begins_with_one`。

```xml
<extension name="break-demo">
	<condition field="destination_number" expression="^1(\d+)$" break="never">
		<action application="set" data="begins_with_one=true"/>
	</condition>
	<condition field="destination_number" expression="^(\d+)$">
	 ...可能查询begins_with_one的其他操作...
	</condition>
</extension>
```

##### Asterisk 模式匹配

除了 PCRE 外，FreeSWITCH 还支持 Asterisk [模式](http://www.voip-info.org/wiki/view/Asterisk+Dialplan+Patterns)。以下划线 (\_) 开头的任何表达式都将使用 Asterisk 模式匹配进行处理。请参阅 [mod\_dialplan\_asterisk](../../Modules/mod_dialplan_asterisk_3966416.mdx#about)。

由于在正则表达式中 * 通常是保留字符，因此在 Asterisk 模式中使用时必须使用 \\ 进行转义，如下面示例的第二部分所示。

```xml
<extension name="US-Domestic">
	<condition field="destination_number" expression="_(NXXXXXXXXX)">
	<action application="bridge" data="sofia/internal/$1@example.com"/>
	</condition>
</extension>
 
<extension name="star-code-using-escape">
	<condition field="destination_number" expression="_(\*XX)(.)">
		<action application="log" data="ERR captured $1 ~~~ $2"/>
		<action application="answer"/>
		<action application="playback" data="tone_stream://path=${base_dir}/conf/tetris.ttml;loops=10"/>
	</condition>
</extension>
```

### 示例库

这个示例演示了如何在执行操作之前确保所有表达式均匹配，否则将执行相应的反操作。在此情况下，SIP网关必须是默认提供商，并且必须是紧急呼叫，并且必须启用并存储在数据库中的自动应答选项：

```xml
<condition regex="all">
	<regex field="${sip_gateway}" expression="^${default_provider}$"/>
	<regex field="${emergency_call}" expression="^true$"/>
	<regex field="${db(select/emergency/autoanswer)}" expression="^1$"/>
 
	<!-- 如果所有正则表达式都通过，则执行以下操作 -->
	<action application="set" data="call_timeout=60"/>
	<action application="set" data="effective_caller_id_name=${regex(${caller_id_name}|^Emerg(_.*)$|Auto%1)}"/>
	<action application="set" data="autoanswered=true"/>
	<action application="bridge" data="user/1000@${domain_name},sofia/gateway/1006_7217/${mobile_number}"/>
 
	<!-- 如果任何一个正则表达式失败，则执行以下反操作 -->
	<anti-action application="set" data="effective_caller_id_name=${regex(${caller_id_name}|^Emerg(_.*)$|NotAuto%1)}"/>
	<anti-action application="set" data="call_timeout=30"/>
	<anti-action application="set" data="autoanswered=false"/>
	<anti-action application="bridge" data="user/1000@${domain_name},sofia/gateway/1006_7217/${mobile_number}"/>
</condition>
```

  
##### 呼叫者配置文件字段 vs. 通道变量

可能让人感到困惑的一件事是[呼叫者配置文件字段](../Caller-Profile-Field_7144625.mdx#about)（内置变量）和通道变量之间的区别。

呼叫者配置文件字段可以这样访问：

```xml
<condition field="destination_number" attributes...>
```

  
而通道变量可以这样访问：

```xml
<condition field="${sip_has_crypto}" attributes...>
```

请注意 **${variable\_name}** 的语法。通道变量也可以在操作语句中使用。

此外，可以在条件语句中调用API函数来提供动态数据。

例如，可以使用 **cond** API：

```xml
<condition field="${cond(${my_var} > 12 ? YES : NO)}" expression="^YES$">
    <action application="log" data="INFO ${my_var} 确实大于12"/>
</condition>
```

此示例测试 ${my\_var}。如果它大于12，则返回“YES”。否则返回“NO”。条件测试结果是否为“YES”，并将结果消息记录到FreeSWITCH日志中。

变量的可用性

Asterisk用户请注意！

XML拨号计划可以根据包含表达式的变量来测试许多条件，然而，需要理解的是，在进行第一次转接或执行\_extension之前，并不是所有变量都可以用于条件测试（请参阅下面的解决方法）。

###### 为什么

实质上，XML拨号计划用于呼叫路由，而不是进行复杂或广泛的条件测试和评估。这就是为什么FreeSWITCH提供了Lua、JavaScript、Perl、Python等API的原因，因为它们是比提供一个复杂的XML解决方案（或更糟糕的，一些隐晦而复杂的首字母缩写，比如“AEL”）更好的选择。

这可能会让以前使用Asterisk的用户感到困惑，因为诸如&lt;action application="info"/>之类的info应用程序实际上会显示变量，就好像它们可以用于条件测试，实际上可能是不可用的。

这样设计的原因是，FreeSWITCH将**hunting**和**executing**分为两个独立的步骤。首先，根据条件、动作和反动作，收集所有需要执行的应用程序。然后，执行这些应用程序的顺序。这意味着被执行的应用程序设置的通道变量在hunting时不会对条件可用。

这就是为什么即使变量及其值在&lt;action application="info"/>中显示，您可能会发现XML条件失败的原因。

###### 解决方法

解决方法是在Lua、JavaScript或其他Dialplan脚本语言中实现绝大部分拨号计划逻辑，或者执行一个扩展，使您要对其进行条件评估的变量能够在XML拨号计划条件中进行解析。

**注意：**自从[f21b4a21374](https://freeswitch.org/stash/projects/FS/repos/freeswitch/commits/f21b4a2137410550b4ba9ee493ec27a555b53e90)以来，某些应用程序可以以**[inline](#inline-actions)**的方式运行。这意味着它们会在hunting时执行，这样由这些应用程序设置的通道变量将在后续的条件中对hunting时可用。

  
##### 动作和反动作

到目前为止，我们已经看到了包含条件以及当条件匹配时运行的动作的示例拨号计划条目。

您还可以指定当分机的条件未满足时运行的`反动作`。

在此示例中，将${my\_var}的值与12进行比较，并根据结果记录一条消息。

```xml
<condition field="${cond(${my_var} > 12 ? YES : NO)}" expression="^YES$">
    <action application="log" data="INFO ${my_var} 的确大于12"/>
    <anti-action application="log" data="INFO ${my_var} 不大于12"/>
</condition>
```

##### 可用的动作

请参阅[模块](../../Modules/index.mdx#about)和[拨号计划函数](../../Modules/mod_dptools_1970333.mdx#-c)

##### 内联动作

您可以在动作上设置额外的属性**inline="true"**，以便在拨号计划的寻呼阶段执行它：

```xml
<action inline="true" application="set" data="some_var=some_val"/>
```

这样就可以在下一个分机上设置一个条件，匹配**${some\_var}**字段。

请注意，只有那些能够快速获取或设置一些变量并且不访问或修改当前会话状态的应用程序才可以进行内联运行。

允许在内联中运行的应用程序有：

[check\_acl](../../Modules/mod-dptools/6587574.mdx#about)

[eval](../../Modules/mod-dptools/6586572.mdx#about)

[event](../../Modules/mod-dptools/6586582.mdx#about)

[export](../../Modules/mod-dptools/6586592.mdx#about)

[log](../../Modules/mod-dptools/6586596.mdx#about)

[presence](../../Modules/mod-dptools/6586515.mdx#api)

[set](../../Modules/mod-dptools/6586661.mdx#about)

[set\_global](../../Modules/mod-dptools/6587112.mdx#about)

[set\_profile\_var](../../Modules/mod-dptools/6587119.mdx#about)

[set\_user](../../Modules/mod-dptools/6587133.mdx#about)

[unset](../../Modules/mod-dptools/6586914.mdx#about)

[verbose\_events](../../Modules/mod-dptools/6586892.mdx#about)

[cidlookup](../../Modules/mod_cidlookup_1966667.mdx#-configuration-)

[curl](../../Modules/mod_curl_3965033.mdx#application)
```

将文本翻译为简体中文：

[easyroute](../../Modules/mod_easyroute_3966222.mdx#dialplan-examples)

[enum](../../Modules/mod_enum_6587333.mdx#dialplan-apps)

[lcr](../../Modules/mod_lcr_6587457.mdx#dialplan-application)

[nibblebill](../../Modules/mod_nibblebill_3966513.mdx#api-commands)

[odbc_query](../../Modules/mod_odbc_query_6587371.mdx#--)

还要记住，内联执行的应用程序不会像通常运行的应用程序一样出现在您的通话详单记录中。

##### 完整语法

```xml
<!-- 对于枚举属性，列表上的第一个值是默认值 -->
 
<extension name="unique_extension_name" continue="[false|true]">
    <condition field="[field_name|${variable_name}|${api_func(api_args ${var_name})}]" expression="regular expression" break="[on-false|on-true|always|never]" require-nested="[true|false]">
        <condition ...><!-- 条件可以嵌套使用 --> ... </condition>
        <action application="app name" data="app arg"/>
        <anti-action application="app name" data="app arg"/>
    </condition>                                             <!-- 可以跟随任意数量的条件标签，规则相同 -->
</extension>
```

##### 概要

扩展呼叫会在条件评估为true和continue="false"（默认值）的第一个扩展处停止。

如果最后一个检查的条件为true，则条件评估为true。

条件按深度优先方式进行检查，直到以下情况发生：  
 break="on-false"且条件为false  
或  
 break="on-true"且条件为true  
或  
 break="always"。

如果表达式测试返回匹配项，并且没有嵌套条件或require-nested="false"或嵌套条件评估为true，则条件为true。

如果条件为真，将收集每个`<action>`以供执行；如果条件为假，则将收集每个`<anti-action>`以供执行。

如果`require-nested="true"`（默认情况），并且嵌套条件计算结果为假，则不会收集任何`<anti-action>`。（这是有意的吗？）

##### 其他拨号计划的智慧宝贝

在呼叫进入拨号计划解析器处于ROUTING状态时，将对拨号计划进行一次解析。通过对XML进行一次解析，将根据解析的`<action>`或`<anti-action>`标签，将完整的指令列表安装到通道中。

习惯于Asterisk的人可能期望呼叫在解析拨号计划时按照顺序执行应用程序，从一个动作获取的数据可以影响下一个动作。但实际情况**并非**如此，例外情况是`${api func(api arg ${var_name})}`字段类型，其中一个可插拔的模块API调用可以在解析过程中执行。它用于获取实时信息，如日期时间或其他快速访问的信息，不应被滥用。换句话说，在拨号计划的中间不要执行长时间运行的进程。

##### 自动寻呼

你可以打开[auto\_hunt](../Variables-Master-List_16352570.mdx#auto_hunt)，然后如果分机名与拨出号码完全匹配，则FreeSWITCH将跳转到该分机开始搜索。尽管如此，它可能匹配或者不匹配条件。

##### 通过网关拨号

"gateway"在mod\_sofia中被视为关键字，它明显意味着呼叫将通过配置的网关进行传输。这是对于sofia/profilename/extension@ip-address模式的一个例外。

例如，如果一个网关被命名为"gw"，那么将呼叫发送到gw的分机100的桥接字符串为：

```xml
<extension name="testing">
    <condition field="destination_number" expression="^(100)$">
        <action application="bridge" data="sofia/gateway/gw/$1"/>
    </condition>
</extension>
```

`destination_number` 是一个FreeSWITCH变量，不应该被更改。

### 示例

**注意：**如果您计划将您的扩展放在一个单独的.XML文件中：

如果您不需要它，请禁用或更改enum扩展

添加`<include>`标签，并用&lt;/include>关闭。

#### 示例1：匹配条件

只有当呼入电话来自192.168.1.1时，才进行桥接。如果是，则目的地号码将在$1中被捕获，并将呼叫桥接到相同号码，位于192.168.2.2上。

这是一个奇怪的例子。我们可以做得更好。

```xml
<extension name="Test1">
    <condition field="network_addr" expression="^192\.168\.1\.1$"/>
    <condition field="destination_number" expression="^(\d+)$">
        <action application="bridge" data="sofia/profilename/$1@192.168.2.2"/>
    </condition>
</extension>
```

请注意，此示例与以下方式不同：

```xml
<extension name="Test1Wrong">
    <condition field="destination_number" expression="^(\d+)$"/>
    <condition field="network_addr" expression="^192\.168\.1\.1$">
        <action application="bridge" data="sofia/profilename/$1@192.168.2.2"/>
    </condition>
</extension>
```

呼叫**将不能**正确路由，因为在创建它的条件之外，$1中捕获的目标号码是不可用的。这是捕获值工作的一种特殊情况。您可以通过将捕获的值存储在标准变量中来解决此问题，如下所示：

```xml
<extension name="Test1_2">
	<condition field="destination_number" expression="^(\d+)$">
		<action application="set" data="dialed_number=$1"/>
	</condition>
	<condition field="network_addr" expression="^192\.168\.1\.1$">
		<action application="bridge" data="sofia/profilename/${dialed_number}@192.168.2.2"/>
	</condition>
</extension>
```

#### 示例2：匹配多个条件（AND）

在这个例子中，我们需要同时匹配以前缀1开头的被叫号码和传入IP地址。

```xml
<extension name="Test2">
	<condition field="network_addr" expression="^192\.168\.1\.1$"/>
	<condition field="destination_number" expression="^1(\d+)$">
		<action application="bridge" data="sofia/profilename/$0@192.168.2.2"/>
	</condition>
</extension>
```

请注意，尽管我们使用规则1（\\d+）$进行匹配，但我们不使用只包含去掉前导1的拨号剩余号码的变量$1，而是使用包含原始目标号码的变量$0。

#### 示例3：去除前导数字

在这个例子中，我们需要匹配以00开头的被叫号码，但我们还需要去掉前导数字。假设FreeSWITCH™收到号码00123456789，我们需要去掉前导的00数字，然后我们可以使用以下扩展：

```xml
<extension name="Test3.1">
	<condition field="destination_number" expression="^00(\d+)$">
		<action application="bridge" data="sofia/profilename/$1@192.168.2.2"/>
	</condition>
</extension>
```

如果你预计收到非数字字符，或者想匹配的内容不仅限于数字，你可以使用“.+”代替“\d+”。

在使用包含(`.*`)或(`.+`)的正则表达式时要小心。正则表达式越具体，系统被未经授权的用户攻击的可能性就越小。

#### 示例4：添加前缀

在这个示例中，以00开头的号码将被转换成相同的号码，只是以011开头。如果FreeSWITCH™接收到00123456789，我们应该拨打011123456789：

```xml
<extension name="Test4">
	<condition field="destination_number" expression="^00(\d+)$">
		<action application="bridge" data="sofia/profilename/011$1@x.x.x.x"/>
	</condition>
</extension>
```

#### 示例5：SIP配置文件（带不同配置的拨号）

在这个示例中，我们将演示在使用支持配置文件的FreeSWITCH终端时如何使用配置文件，比如[mod\_sofia](../../Configuration/Sofia-SIP-Stack/index.mdx#faq)。假设我们想要对不同的IP地址发送的呼叫使用不同的呼叫设置（编解码器、DTMF模式等），我们可以创建不同的配置文件。例如，在sofia.conf的配置中，我们可以看到一个名为"test"的示例配置文件，我们将其重命名为profile1，并添加一个profile2以进行比较：

```xml
<profile name="profile1">
    <param name="debug" value="1"/>
    <param name="rfc2833-pt" value="101"/>
    <param name="sip-port" value="5060"/>
    <param name="dialplan" value="XML"/>
    <param name="dtmf-duration" value="100"/>
    <param name="codec-prefs" value="PCMU@20i"/>
    <param name="codec-ms" value="20"/>
    <param name="use-rtp-timer" value="true"/>
</profile>
<profile name="profile2">
    <param name="debug" value="1"/>
    <param name="rfc2833-pt" value="101"/>
    <param name="sip-port" value="5070"/>
    <param name="dialplan" value="XML"/>
    <param name="dtmf-duration" value="100"/>
    <param name="codec-prefs" value="PCMA@20i"/>
    <param name="codec-ms" value="20"/>
    <param name="use-rtp-timer" value="true"/>
</profile> 
```

这两个配置文件的区别在于所使用的音频编解码。第一个配置文件使用 G.711 u-law 编码，而第二个配置文件使用 G.711 A-law 编码。

接下来是以上示例的一个延续：

```xml
 <extension name="Test5ulaw">
    <condition field="network_addr" expression="^192\.168\.1\.1$"/>
    <condition field="destination_number" expression="^1(\d+)$">
        <action application="bridge" data="sofia/profile1/$0@192.168.2.2"/>
    </condition>
</extension>
```

它用于以 G.711 u-law 格式发送呼叫，并且

```xml
<extension name="Test5alaw">
    <condition field="network_addr" expression="^192\.168\.1\.1$"/>
    <condition field="destination_number" expression="^1(\d+)$">
        <action application="bridge" data="sofia/profile2/$0@192.168.2.2"/>
    </condition>
</extension>
```

  
#### 示例 6：呼叫已注册用户

这个例子展示了如何与已经在你的FreeSWITCH盒子上注册的设备进行桥接。在这个例子中，我们假设你已经设置了一个名为'local_profile'的sofia配置文件，并且你的手机正在使用`example.com`域名进行注册。

在拨号字符串中，`%`取代了`@`，表示一个已经注册到FreeSWITCH的终端。

```xml
 <extension name="internal">
    <condition field="source" expression="mod_sofia" />
    <condition field="destination_number" expression="^(4\d+)">
        <action application="bridge" data="sofia/local_profile/$1%example.com" />
    </condition>
</extension>
```

#### 示例7: 在动作失败时进行故障转移

下面的示例展示了如果第一个动作失败，如何调用另一个动作。

如果第一个动作成功，呼叫将被桥接到`1111@example1.company.com`，并直到一方挂断为止。之后，不会进行其他处理，因为呼叫者的通道已关闭。（即`1111@example2.company.com`不会被调用）

如果对`1111@example1.company.com`的初始呼叫**不**成功，则通道不会关闭，将调用第二个动作。

```xml
 <extension name="internal">
    <condition field="destination_number" expression="^1111">
        <action application="set" data="hangup_after_bridge=true"/>
        <action application="bridge" data="sofia/local_profile/1111@example1.company.com" />
        <action application="bridge" data="sofia/local_profile/1111@example2.company.com" />
    </condition>
</extension>
```

注意：如果你有多个动作，并且第一个动作的应用程序会**挂断通道**，则不会调用第二个动作。

如果第一个动作的应用程序**不会挂断通道**，则会调用第二个动作。

#### 示例8：检查用户是否已验证

以下示例要求调用者在通过之前进行身份验证。它是从邮件列表的帖子中摘录的。

```xml
 <extension name="9191">
    <condition field="destination_number" expression="^9191$"/>
    <condition field="${sip_authorized}" expression="true">
        <anti-action application="respond" data="407"/>
    </condition>
    <condition>
        <action application="playback" data="/tmp/itworked.wav"/>
    </condition>
</extension>
```

  
#### **示例9：将DID路由到分机**

要将来电路由到特定DID对应的固定分机1001，可以使用类似以下方式（源自邮件列表帖子）（其中XXXxxxxxxx是您的来电DID的电话号码）

在public.xml中：

```xml
 <extension name="test_did">
    <condition field="destination_number" expression="^(XXXxxxxxxx)$">
        <action application="transfer" data="$1 XML default"/>
    </condition>
</extension>
```

  
然后在default.xml的默认上下文中添加类似以下内容：

```xml
<extension name="本地扩展">
    <condition field="destination_number" expression="^(XXXxxxxxxx)$">
        <action application="set" data="dialed_ext=$1"/>
    </condition>
    <condition field="destination_number" expression="^${caller_id_number}$">
        <action application="set" data="voicemail_authorized=${sip_authorized}"/>
        <action application="answer"/>
        <action application="sleep" data="1000"/>
        <action application="voicemail" data="check default $${domain} ${dialed_ext}"/>
        <anti-action application="ring_ready"/>
        <anti-action application="set" data="call_timeout=10"/>
        <anti-action application="set" data="hangup_after_bridge=true"/>
        <anti-action application="set" data="continue_on_fail=true"/>
        <anti-action application="bridge" data="USER/1001@$${domain}"/>
        <anti-action application="answer"/>
        <anti-action application="sleep" data="1000"/>
        <anti-action application="voicemail" data="default $${domain} ${dialed_ext}"/>
    </condition>
</extension>
```

  
（"bridge"行中的1001是我们要呼叫的分机）

须知，来自“public”的呼叫进入公共上下文，然后需要转移到其他更友好的上下文进行处理，例如“default”。这就是为什么要添加条目到公共上下文，并且'data="$1 XML default"'表示使用XML拨号计划将被呼叫的号码$1转移到上下文"default"。实际上，在"default"上下文中，呼叫被连线到期望的电话。

$${domain}是在vars.xml中设置为域的变量，很可能是您的IP地址或主机名。

#### 示例10：将呼叫路由到具有自定义呼叫ID的网关扩展

在这个例子中，我们演示了通过10位数字从分机号1000发出的呼叫，然后将其路由到`asterlink.com`网关。这个例子展示了如何为特定的分机号设置路由，并允许自定义呼叫方标识。

```xml
<extension name="asterlink.com">
    <condition field="caller_id_number" expression="^1000$"/>
    <condition field="destination_number" expression="^(\d{10})$">
        <action application="set" data="effective_caller_id_number=8001231234"/>
        <action application="set" data="effective_caller_id_name=800号码"/>
        <action application="bridge" data="sofia/gateway/asterlink.com/1208$1"/>
    </condition>
</extension>
```

#### 示例11：基于号码前缀进行路由

在这个例子中，我们演示了基于NPANXX进行不同目标地的路由。还演示了如何对呼叫方做出不同的失败消息响应，而不是目标发送给FreeSWITCH的消息。

```xml
<extension>
    <condition field="network_addr" expression="^(66\.123\.321\.231|70\.221\.221\.221)$" break="on-false"/>
    <condition field="destination_number" expression="^\d+$" break="never">
        <action application="set" data="continue_on_fail=NORMAL_TEMPORARY_FAILURE,TIMEOUT,NO_ROUTE_DESTINATION"/>
        <action application="set" data="bypass_media=true"/>
        <action application="set" data="accountcode=myaccount"/>
    </condition>
    <condition field="destination_number" expression="^(1813\d+|1863\d+|1727\d+|1941\d+|404\d+)$" break="never">
        <action application="bridge" data="sofia/outbound_profile/${sip_to_user}@switch1.mydomain.com"/>
        <action application="info"/>
        <action application="respond" data="503"/>
        <action application="hangup"/>
    </condition>
    <condition field="destination_number" expression="^(1404\d+|1678\d+|1770\d+)$">
        <action application="bridge" data="sofia/outbound_profile/${sip_to_user}@switch2.mydomain.com"/>
        <action application="info"/>
        <action application="respond" data="503"/>
        <action application="hangup"/>
        <anti-action application="respond" data="503"/>
        <anti-action application="hangup"/>
    </condition>
</extension>
```
  
#### 示例 12：处理未匹配到扩展的呼叫

在本示例中，我们演示了如何捕获无效的扩展或目标号码。

您需要在ENUM被包含之前，在您的呼叫计划的底部添加此扩展。

查看 [mod\_enum](../../Modules/mod_enum_6587333.mdx#enum)。

```xml
<extension name="catchall">
    <condition field="destination_number" expression=".*" continue="true">
        <action application="playback" data="misc/invalid_extension.wav"/>
    </condition>
</extension>
```

#### 示例13：来电筛选

在这个示例中，我们要求呼叫者提供姓名，连接到被呼叫方并宣布该姓名。然后被呼叫方可以按1接听呼叫，或挂断。如果被呼叫方挂断，呼叫者将连接到语音信箱。

```xml
<extension name="screen">
    <condition field="destination_number" expression="^(\d{4})$">
        <action application="set" data="call_screen_filename=/tmp/${caller_id_number}-name.wav"/>
        <action application="set" data="hangup_after_bridge=true" />
        <action application="answer"/>
        <action application="sleep" data="1000"/>
        <action application="phrase" data="voicemail_record_name"/>
        <action application="playback" data="tone_stream://%(500, 0, 640)"/>
        <action application="set" data="playback_terminators=#*0123456789"/>
        <action application="record" data="${call_screen_filename} 7 200 2"/>
        <action application="set" data="group_confirm_key=1"/>
        <action application="set" data="fail_on_single_reject=true"/>
        <action application="set" data="group_confirm_file=phrase:screen_confirm:${call_screen_filename}"/>
        <action application="set" data="continue_on_fail=true"/>
        <action application="bridge" data="user/$1"/>
        <action application="voicemail" data="default $${domain} $1"/>
        <action application="hangup"/>
    </condition>
</extension>
```

#### 示例14：媒体录制

此扩展用于以音频（wav）格式播放/录制媒体的录制/回放扩展

感谢 rupa 的帮助。

```xml
  <extension name="recording">
    <condition field="destination_number" expression="^(2020)$">
        <action application="answer"/>
        <action application="set" data="playback_terminators=#"/>
        <action application="record" data="/tmp/recorded.wav 20 200"/>
    </condition>
</extension>
<extension name="playback">
    <condition field="destination_number" expression="^(2021)$">
        <action application="answer"/>
        <action application="set" data="playback_terminators=#"/>
        <action application="playback" data="/tmp/recorded.wav"/>
    </condition>
</extension>
```

  
#### Example 15: Speaking Clock

This example will speak time using the Flite text to speech engine.

See: [mod\_flite](../../Modules/mod_flite_3965160.mdx#about)

```xml
<include>
    <extension name="SpeakTime">
        <condition field="destination_number" expression="^2910$">
            <action application="set" data="actime=${strftime(%H:%M)}"/>
            <action application="set" data="tts_engine=flite"/>
            <action application="set" data="tts_voice=slt"/>
            <action application="speak" data="It is +${actime}"/>
        </condition>
    </extension>
</include>
```

  
#### Example 16: Block certain codes

This extension example is to demonstrate how to block certain NPAs that you do not want to terminate based on caller id area codes and respond with SIP:503 to your origination so that they can route advance if they have another carrier to terminate the call.

```xml
<extension name="blocked_cid_npa">
    <condition field="caller_id_number" expression="^(\+1|1)?((876|809)\d{7})$">
        <action application="respond" data="503"/>
        <action application="hangup"/>
    </condition>
</extension>
```

#### 示例17：从入站DID接收传真

要在来电时使用freeswitch/conf/dialplan/default.xml中预定义的fax_receive扩展，请在freeswitch/conf/dialplan/public/fax.xml中添加以下内容：

```xml
<include>
    <extension name="incoming-fax">
        <condition field="destination_number" expression="^$${local_fax_number}$">
            <action application="set" data="domain_name=$${domain}"/>
            <action application="transfer" data="9178 XML default"/>
        </condition>
    </extension>
</include>
```

然后在freeswitch/conf/vars.xml中将传真号码设置为1234或其他号码：

```xml
<X-PRE-PROCESS cmd="set" data="local_fax_number=1234"/>
```

#### 示例18：为呼入的BRI呼叫添加国际呼叫前缀

在使用FreeTDM与BRI线路的情况下，接收到的呼入电话的caller_id_number中将不包含国际呼叫前缀。此扩展将其添加到effective_caller_id_number中。

国际呼叫前缀的说明请参见：[国际前缀](http://en.wikipedia.org/wiki/International%5Fprefix)。

在德国，国际呼叫前缀称为“Verkehrsausscheidungsziffer”（VAZ），请参见[这里](http://de.wikipedia.org/wiki/Verkehrsausscheidungsziffer)。

国际呼叫前缀永远不会被传输。可以通过查看ToN信息来预测它。

```xml
<extension name="Add-VAZ" continue="true">
    <!-- 在呼入的BRI呼叫中，Verkehrsausscheidungsziffer（VAZ）会被忽略。此扩展会将其再次添加到caller_id_number中。TODO：增加对国际号码的支持-->
    <condition field="source" expression="^mod_freetdm$">
        <action application="set" data="effective_caller_id_number=0${caller_id_number}"/>
    </condition>
</extension>
```

示例19：DISA

能够拨号进入FS盒子并获得拨号音来重新拨号，就像在Asterisk的DISA()函数中一样。

在FS/conf/dialplan/public/\*.xml中

```xml
<!-- -->
<!-- -->
<!-- -->
<!-- 注意！！！这里是转接。可能存在安全漏洞。注意！！！ -->
<!-- -->
<!-- -->
<!-- -->
<extension name="incoming-bri-wor">
    <condition field="destination_number" expression="^(disa_target)$">
        <action application="answer"/>
        <action application="start_dtmf"/>
        <action application="play_and_get_digits" data="2 5 3 37000 # $${base_dir}/sounds/en/us/callie/ivr/8000/ivr-please_enter_pin_followed_by_pound.wav $${base_dir}/sounds/en/us/callie/ivr/8000/ivr-pin_or_extension_is-invalid.wav digits ^$${DISA_PASSWORD}$"/>
        <action application="transfer" data="$1 XML default"/>
    </condition>
</extension>
<!-- -->
<!-- -->
<!-- -->
<!-- 注意！！！这里是转接。可能存在安全漏洞。注意！！！ -->
<!-- -->
<!-- -->
<!-- -->
<extension name="incoming-bri-wor">
    <condition field="destination_number" expression="^(disa_target)$">
        <action application="answer"/>
        <action application="start_dtmf"/>
        <action application="play_and_get_digits" data="2 5 3 37000 # $${base_dir}/sounds/en/us/callie/ivr/8000/ivr-please_enter_pin_followed_by_pound.wav $${base_dir}/sounds/en/us/callie/ivr/8000/ivr-pin_or_extension_is-invalid.wav digits ^$${DISA_PASSWORD}$"/>
        <action application="transfer" data="$1 XML default"/>
    </condition>
</extension>
```

在FS/conf/dialplan/default/03_DISA.xml中

```xml
<!-- DISA - 允许拨号进入盒子并获得一个像新建扩展线一样的拨号音 -->
<include>
    <extension name="DISA for FS">
        <condition field="destination_number" expression="^(disa_target)$">
            <action application="answer"/>
            <action application="read" data="2 15 'tone_stream://%(10000,0,350,440)' digits 30000 #"/>
            <action application="execute_extension" data="${digits}"/>
            <action application="transfer" data="disa_target XML default"/>
        </condition>
    </extension>
</include>
```

请将 "disa_target" 替换为您的分机号码。

您可以使用此技术从公网电话/移动电话拨入您的设备，并获得拨号音以执行任何操作。

#### 示例20：修复无效的呼叫方ID

如果您遇到这样的问题：您的B-Leg不喜欢无效的呼叫方ID，例如，您收到一个带有 From: 头的 INVITE 消息，其格式为 `From: <sip:Unavailable@Unavailable.invalid:5060>`，您可以强制使用固定的呼叫方ID号码替换无效的号码。以下示例检查一个有效的NANPA CLID：

```xml
<extension name="invalid_caller_id_fix" continue="true">
    <condition field="caller_id_number" expression="^1?([2-9]\d{2}[2-9]\d{6})$">
        <action application="set" data="effective_caller_id_number=$1"/>
        <anti-action application="set" data="effective_caller_id_number=2135551212"/>
    </condition>
</extension>
```

#### 示例21：阻止出局呼叫方ID

要通过拨号 \*67 并输入拨号号码来阻止呼叫方的呼叫方ID，请执行以下操作：

```xml
<extension name="block_caller_id">
    <condition field="destination_number" expression="^\*67(\d+)$">
        <action application="privacy" data="full"/>
        <action application="set" data="sip_h_Privacy=id"/>
        <action application="set" data="privacy=yes"/>
        <action application="transfer" data="$1 XML default"/>
    </condition>
</extension>
```

#### 示例 22：在进行数据库查询时播放MOH

如果您想在进行长时间的数据查询时播放MOH，可以通过使用变量扩展使拨号计划调用FSAPI上的luarun脚本 实现。这样就会启动一个新的线程来执行Lua脚本。

```xml
<extension name="Get_Data">
    <condition field="destination_number" expression="^(Get_Data)$">
        <action application="play_and_get_digits" data="4 16 3 7000 # phrase:Enter_Case_Number phrase:Invalid_entry case_number \d+" />
        <action application="set" data="x=${expand(luarun GetDataFromLDAP.lua ${case_number} ${uuid})}"/>
        <action application = "playback" data="/tmp/LongMusicFile.wav"/>
    </condition>
</extension>
```

在Lua脚本中，您可以使用传递的"uuid"参数来中断MOH或转接到其他分机。

```perl
--GetDataFromLDAP.lua 
key = argv[1] sessionId = argv[2] api = freeswitch.API() --在这里进行数据查询操作 --完成数据库操作后，您可以简单地停止MOH或转接到其他分机 
api:execute("uuid_break", sessionId) -- 中断MOH
```

**SIP特定拨号字符串**

SIP拨号有几种选项。以下是您可能称之为SIP拨号字符串解剖的几个方面。

##### 拨打SIP URI

基本语法是：sofia/my\_profile/user@host Host可以是名称或IP地址，例如：

```xml
sofia/my_profile/1234@192.168.0.1
```

这将通过"profile"连接，拨打192.168.0.1主机上的号码1234。如果你使用的是一个名称而不是IP地址，Sofia会尝试将该名称解析为NAPTR或SRV记录，然后再作为标准的A记录来尝试拨打。

##### 拨打已注册用户

根据域是否有[别名](../../Modules/mod_commands_1966741.mdx#command-2)，有两个选项可供选择。  
如果没有别名，则可以这样做：

```xml
sofia/my_profile/1234%mydomain.com
```

如果域有别名，则此语法是有效的：

```xml
sofia/mydomain.com/1234
```

注意拨号字符串中不需要显式地提供配置文件。

还可以使用以下方式拨打在[目录](../../Directory/XML-User-Directory/index.mdx#about)中定义的用户：

```xml
user/1234@mydomain.com
```

##### 通过网关拨打（SIP提供商）

网关是通过SIP提供商拨打出站电话的一种手段。例如：

```xml
sofia/gateway/mygateway.com/1234
```

这将通过名为"mygateway.com"的网关拨打到用户"1234"。

注意，用户"1234"后面不需要添加任何内容。  
以下是一个错误示例：

```xml
sofia/gateway/mygateway.com/1234@mygateway.com <==== 错误错误错误
```

##### 使用特定传输方式拨打

有时您需要指定传输方式，例如TCP，UDP，TLS或SCTP。可以通过在后面添加分号和传输方法来实现。例如：

```xml
sofia/my_profile/1234@192.168.0.1;transport=tcp
```

##### 指定编解码器

有时您可能想强制系统使用特定的编解码器。以下语法可以实现这一目的：

```xml
{absolute_codec_string=XXXX}sofia/my_profile/user@your.domain.com
```

在这个例子中，XXXX代表要使用的编解码器。可能的编解码器值列在[这里](../../Codecs-and-Media/Audio-Codecs_1048675.mdx#--)。
来自[Absolute Codec String variables](../Variables-Master-List_16352570.mdx#absolute_codec_string)的其他拨号字符串示例。

##### 使用PortAudio进行高级设置

如果您已经运行了PortAudio，并且希望指定您需要的编解码器以进行原始呼叫和桥接：

```xml
originate {absolute_codec_string=XXXX}sofia/default/foo@bar.com bridge:portaudio/auto_answer inline
```

##### 更改SIP联系人用户

FreeSWITCH通常使用mod\_sofia@ip:port作为内部SIP联系人。要将其更改为foo@ip:port，有一个名为sip\_contact\_user的变量：

```xml
{sip_contact_user=foo}sofia/my_profile/1234@192.168.0.1;transport=tcp
```

##### 使用自定义SIP URI

FreeSWITCH允许您根据需要指定自定义URI。例如，您可能需要与仅接受具有特定格式的URI的设备进行互操作。关键是在拨号字符串中使用"sip:"前缀来指定您的SIP URI。例如：

```xml
sofia/my_profile/sip:xxxx;phone-context=cdp.udp@somedomain.com;user=phone
```

上面的示例将以"sip:"前缀后指定的URI发送出去。

##### 使用命令行测试拨号计划

```xml
originate loopback/<目标号码>/<我的上下文> hangup inline
```

注意：您还可以根据您的拨号计划要求设置您的变量。请参考以下示例：

```xml
originate {toll_allow=international}loopback/0116628888888/default hangup inline
```

##### 设置呼叫转发的SIP Diversion头

```xml
<action application="export" data="sip_h_Diversion=<sip:2134445555@1.2.3.4>;reason=unavailable"/>
```

### 附件：

![](/images/icons/bullet_blue.gif) [LineVsNestedOrder.png](/attachments/3966106/19595477.png) (image/png)  
![](/images/icons/bullet_blue.gif) [ExecutionOrder.png](/attachments/3966106/19595480.png) (image/png)  

### 评论：

| 在正则表达式的示例中，不要忘记我们可能想要使用 `\d{4}` 的格式，或者至少解释一下 `\d{4}` 等同于 `\d\d\d\d`，并且可以允许长度可变。![](/images/icons/contenttypes/comment_16.png) 由 silik0n 在 2014年8月12日15:28发布 |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |